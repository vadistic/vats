// Code generated by Prisma (prisma@1.24.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  application: (where?: ApplicationWhereInput) => Promise<boolean>;
  candidate: (where?: CandidateWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  disqualification: (where?: DisqualificationWhereInput) => Promise<boolean>;
  disqualificationLink: (
    where?: DisqualificationLinkWhereInput
  ) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  field: (where?: FieldWhereInput) => Promise<boolean>;
  fieldLink: (where?: FieldLinkWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  invite: (where?: InviteWhereInput) => Promise<boolean>;
  job: (where?: JobWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  stage: (where?: StageWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  task: (where?: TaskWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  workflow: (where?: WorkflowWhereInput) => Promise<boolean>;
  workspace: (where?: WorkspaceWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  application: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  applications: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Application>;
  applicationsConnection: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplicationConnectionPromise;
  candidate: (where: CandidateWhereUniqueInput) => CandidatePromise;
  candidates: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Candidate>;
  candidatesConnection: (args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CandidateConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  disqualification: (
    where: DisqualificationWhereUniqueInput
  ) => DisqualificationPromise;
  disqualifications: (args?: {
    where?: DisqualificationWhereInput;
    orderBy?: DisqualificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Disqualification>;
  disqualificationsConnection: (args?: {
    where?: DisqualificationWhereInput;
    orderBy?: DisqualificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DisqualificationConnectionPromise;
  disqualificationLink: (
    where: DisqualificationLinkWhereUniqueInput
  ) => DisqualificationLinkPromise;
  disqualificationLinks: (args?: {
    where?: DisqualificationLinkWhereInput;
    orderBy?: DisqualificationLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<DisqualificationLink>;
  disqualificationLinksConnection: (args?: {
    where?: DisqualificationLinkWhereInput;
    orderBy?: DisqualificationLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DisqualificationLinkConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventPromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  field: (where: FieldWhereUniqueInput) => FieldPromise;
  fields: (args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Field>;
  fieldsConnection: (args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FieldConnectionPromise;
  fieldLink: (where: FieldLinkWhereUniqueInput) => FieldLinkPromise;
  fieldLinks: (args?: {
    where?: FieldLinkWhereInput;
    orderBy?: FieldLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FieldLink>;
  fieldLinksConnection: (args?: {
    where?: FieldLinkWhereInput;
    orderBy?: FieldLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FieldLinkConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  invite: (where: InviteWhereUniqueInput) => InvitePromise;
  invites: (args?: {
    where?: InviteWhereInput;
    orderBy?: InviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Invite>;
  invitesConnection: (args?: {
    where?: InviteWhereInput;
    orderBy?: InviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InviteConnectionPromise;
  job: (where: JobWhereUniqueInput) => JobPromise;
  jobs: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Job>;
  jobsConnection: (args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => JobConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationPromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  notification: (where: NotificationWhereUniqueInput) => NotificationPromise;
  notifications: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notification>;
  notificationsConnection: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotificationConnectionPromise;
  stage: (where: StageWhereUniqueInput) => StagePromise;
  stages: (args?: {
    where?: StageWhereInput;
    orderBy?: StageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Stage>;
  stagesConnection: (args?: {
    where?: StageWhereInput;
    orderBy?: StageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StageConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  task: (where: TaskWhereUniqueInput) => TaskPromise;
  tasks: (args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Task>;
  tasksConnection: (args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TaskConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  workflow: (where: WorkflowWhereUniqueInput) => WorkflowPromise;
  workflows: (args?: {
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Workflow>;
  workflowsConnection: (args?: {
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkflowConnectionPromise;
  workspace: (where: WorkspaceWhereUniqueInput) => WorkspacePromise;
  workspaces: (args?: {
    where?: WorkspaceWhereInput;
    orderBy?: WorkspaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Workspace>;
  workspacesConnection: (args?: {
    where?: WorkspaceWhereInput;
    orderBy?: WorkspaceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => WorkspaceConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApplication: (data: ApplicationCreateInput) => ApplicationPromise;
  updateApplication: (args: {
    data: ApplicationUpdateInput;
    where: ApplicationWhereUniqueInput;
  }) => ApplicationPromise;
  updateManyApplications: (args: {
    data: ApplicationUpdateManyMutationInput;
    where?: ApplicationWhereInput;
  }) => BatchPayloadPromise;
  upsertApplication: (args: {
    where: ApplicationWhereUniqueInput;
    create: ApplicationCreateInput;
    update: ApplicationUpdateInput;
  }) => ApplicationPromise;
  deleteApplication: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  deleteManyApplications: (
    where?: ApplicationWhereInput
  ) => BatchPayloadPromise;
  createCandidate: (data: CandidateCreateInput) => CandidatePromise;
  updateCandidate: (args: {
    data: CandidateUpdateInput;
    where: CandidateWhereUniqueInput;
  }) => CandidatePromise;
  updateManyCandidates: (args: {
    data: CandidateUpdateManyMutationInput;
    where?: CandidateWhereInput;
  }) => BatchPayloadPromise;
  upsertCandidate: (args: {
    where: CandidateWhereUniqueInput;
    create: CandidateCreateInput;
    update: CandidateUpdateInput;
  }) => CandidatePromise;
  deleteCandidate: (where: CandidateWhereUniqueInput) => CandidatePromise;
  deleteManyCandidates: (where?: CandidateWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createDisqualification: (
    data: DisqualificationCreateInput
  ) => DisqualificationPromise;
  updateDisqualification: (args: {
    data: DisqualificationUpdateInput;
    where: DisqualificationWhereUniqueInput;
  }) => DisqualificationPromise;
  updateManyDisqualifications: (args: {
    data: DisqualificationUpdateManyMutationInput;
    where?: DisqualificationWhereInput;
  }) => BatchPayloadPromise;
  upsertDisqualification: (args: {
    where: DisqualificationWhereUniqueInput;
    create: DisqualificationCreateInput;
    update: DisqualificationUpdateInput;
  }) => DisqualificationPromise;
  deleteDisqualification: (
    where: DisqualificationWhereUniqueInput
  ) => DisqualificationPromise;
  deleteManyDisqualifications: (
    where?: DisqualificationWhereInput
  ) => BatchPayloadPromise;
  createDisqualificationLink: (
    data: DisqualificationLinkCreateInput
  ) => DisqualificationLinkPromise;
  updateDisqualificationLink: (args: {
    data: DisqualificationLinkUpdateInput;
    where: DisqualificationLinkWhereUniqueInput;
  }) => DisqualificationLinkPromise;
  updateManyDisqualificationLinks: (args: {
    data: DisqualificationLinkUpdateManyMutationInput;
    where?: DisqualificationLinkWhereInput;
  }) => BatchPayloadPromise;
  upsertDisqualificationLink: (args: {
    where: DisqualificationLinkWhereUniqueInput;
    create: DisqualificationLinkCreateInput;
    update: DisqualificationLinkUpdateInput;
  }) => DisqualificationLinkPromise;
  deleteDisqualificationLink: (
    where: DisqualificationLinkWhereUniqueInput
  ) => DisqualificationLinkPromise;
  deleteManyDisqualificationLinks: (
    where?: DisqualificationLinkWhereInput
  ) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createField: (data: FieldCreateInput) => FieldPromise;
  updateField: (args: {
    data: FieldUpdateInput;
    where: FieldWhereUniqueInput;
  }) => FieldPromise;
  updateManyFields: (args: {
    data: FieldUpdateManyMutationInput;
    where?: FieldWhereInput;
  }) => BatchPayloadPromise;
  upsertField: (args: {
    where: FieldWhereUniqueInput;
    create: FieldCreateInput;
    update: FieldUpdateInput;
  }) => FieldPromise;
  deleteField: (where: FieldWhereUniqueInput) => FieldPromise;
  deleteManyFields: (where?: FieldWhereInput) => BatchPayloadPromise;
  createFieldLink: (data: FieldLinkCreateInput) => FieldLinkPromise;
  updateFieldLink: (args: {
    data: FieldLinkUpdateInput;
    where: FieldLinkWhereUniqueInput;
  }) => FieldLinkPromise;
  updateManyFieldLinks: (args: {
    data: FieldLinkUpdateManyMutationInput;
    where?: FieldLinkWhereInput;
  }) => BatchPayloadPromise;
  upsertFieldLink: (args: {
    where: FieldLinkWhereUniqueInput;
    create: FieldLinkCreateInput;
    update: FieldLinkUpdateInput;
  }) => FieldLinkPromise;
  deleteFieldLink: (where: FieldLinkWhereUniqueInput) => FieldLinkPromise;
  deleteManyFieldLinks: (where?: FieldLinkWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createInvite: (data: InviteCreateInput) => InvitePromise;
  updateInvite: (args: {
    data: InviteUpdateInput;
    where: InviteWhereUniqueInput;
  }) => InvitePromise;
  updateManyInvites: (args: {
    data: InviteUpdateManyMutationInput;
    where?: InviteWhereInput;
  }) => BatchPayloadPromise;
  upsertInvite: (args: {
    where: InviteWhereUniqueInput;
    create: InviteCreateInput;
    update: InviteUpdateInput;
  }) => InvitePromise;
  deleteInvite: (where: InviteWhereUniqueInput) => InvitePromise;
  deleteManyInvites: (where?: InviteWhereInput) => BatchPayloadPromise;
  createJob: (data: JobCreateInput) => JobPromise;
  updateJob: (args: {
    data: JobUpdateInput;
    where: JobWhereUniqueInput;
  }) => JobPromise;
  updateManyJobs: (args: {
    data: JobUpdateManyMutationInput;
    where?: JobWhereInput;
  }) => BatchPayloadPromise;
  upsertJob: (args: {
    where: JobWhereUniqueInput;
    create: JobCreateInput;
    update: JobUpdateInput;
  }) => JobPromise;
  deleteJob: (where: JobWhereUniqueInput) => JobPromise;
  deleteManyJobs: (where?: JobWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (args: {
    data: LocationUpdateInput;
    where: LocationWhereUniqueInput;
  }) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  upsertLocation: (args: {
    where: LocationWhereUniqueInput;
    create: LocationCreateInput;
    update: LocationUpdateInput;
  }) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (args: {
    data: NotificationUpdateInput;
    where: NotificationWhereUniqueInput;
  }) => NotificationPromise;
  updateManyNotifications: (args: {
    data: NotificationUpdateManyMutationInput;
    where?: NotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertNotification: (args: {
    where: NotificationWhereUniqueInput;
    create: NotificationCreateInput;
    update: NotificationUpdateInput;
  }) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createStage: (data: StageCreateInput) => StagePromise;
  updateStage: (args: {
    data: StageUpdateInput;
    where: StageWhereUniqueInput;
  }) => StagePromise;
  updateManyStages: (args: {
    data: StageUpdateManyMutationInput;
    where?: StageWhereInput;
  }) => BatchPayloadPromise;
  upsertStage: (args: {
    where: StageWhereUniqueInput;
    create: StageCreateInput;
    update: StageUpdateInput;
  }) => StagePromise;
  deleteStage: (where: StageWhereUniqueInput) => StagePromise;
  deleteManyStages: (where?: StageWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTask: (data: TaskCreateInput) => TaskPromise;
  updateTask: (args: {
    data: TaskUpdateInput;
    where: TaskWhereUniqueInput;
  }) => TaskPromise;
  updateManyTasks: (args: {
    data: TaskUpdateManyMutationInput;
    where?: TaskWhereInput;
  }) => BatchPayloadPromise;
  upsertTask: (args: {
    where: TaskWhereUniqueInput;
    create: TaskCreateInput;
    update: TaskUpdateInput;
  }) => TaskPromise;
  deleteTask: (where: TaskWhereUniqueInput) => TaskPromise;
  deleteManyTasks: (where?: TaskWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWorkflow: (data: WorkflowCreateInput) => WorkflowPromise;
  updateWorkflow: (args: {
    data: WorkflowUpdateInput;
    where: WorkflowWhereUniqueInput;
  }) => WorkflowPromise;
  updateManyWorkflows: (args: {
    data: WorkflowUpdateManyMutationInput;
    where?: WorkflowWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkflow: (args: {
    where: WorkflowWhereUniqueInput;
    create: WorkflowCreateInput;
    update: WorkflowUpdateInput;
  }) => WorkflowPromise;
  deleteWorkflow: (where: WorkflowWhereUniqueInput) => WorkflowPromise;
  deleteManyWorkflows: (where?: WorkflowWhereInput) => BatchPayloadPromise;
  createWorkspace: (data: WorkspaceCreateInput) => WorkspacePromise;
  updateWorkspace: (args: {
    data: WorkspaceUpdateInput;
    where: WorkspaceWhereUniqueInput;
  }) => WorkspacePromise;
  updateManyWorkspaces: (args: {
    data: WorkspaceUpdateManyMutationInput;
    where?: WorkspaceWhereInput;
  }) => BatchPayloadPromise;
  upsertWorkspace: (args: {
    where: WorkspaceWhereUniqueInput;
    create: WorkspaceCreateInput;
    update: WorkspaceUpdateInput;
  }) => WorkspacePromise;
  deleteWorkspace: (where: WorkspaceWhereUniqueInput) => WorkspacePromise;
  deleteManyWorkspaces: (where?: WorkspaceWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  application: (
    where?: ApplicationSubscriptionWhereInput
  ) => ApplicationSubscriptionPayloadSubscription;
  candidate: (
    where?: CandidateSubscriptionWhereInput
  ) => CandidateSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  disqualification: (
    where?: DisqualificationSubscriptionWhereInput
  ) => DisqualificationSubscriptionPayloadSubscription;
  disqualificationLink: (
    where?: DisqualificationLinkSubscriptionWhereInput
  ) => DisqualificationLinkSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  field: (
    where?: FieldSubscriptionWhereInput
  ) => FieldSubscriptionPayloadSubscription;
  fieldLink: (
    where?: FieldLinkSubscriptionWhereInput
  ) => FieldLinkSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  invite: (
    where?: InviteSubscriptionWhereInput
  ) => InviteSubscriptionPayloadSubscription;
  job: (
    where?: JobSubscriptionWhereInput
  ) => JobSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  stage: (
    where?: StageSubscriptionWhereInput
  ) => StageSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  task: (
    where?: TaskSubscriptionWhereInput
  ) => TaskSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  workflow: (
    where?: WorkflowSubscriptionWhereInput
  ) => WorkflowSubscriptionPayloadSubscription;
  workspace: (
    where?: WorkspaceSubscriptionWhereInput
  ) => WorkspaceSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ApplicationType = "Qualified" | "Disqualified";

export type EventType =
  | "Default"
  | "Message"
  | "CommentCreate"
  | "CommentEdit"
  | "CommentDelete";

export type EventActorType = "System" | "User" | "Candidate";

export type StageType = "New" | "Pipeline" | "Final";

export type FieldType =
  | "Int"
  | "Float"
  | "String"
  | "Text"
  | "Boolean"
  | "DateTime";

export type JobType = "Draft" | "Published" | "Archived";

export type NotificationType = "Unread" | "Read";

export type EventTargetType = "Candidate" | "Job" | "Task" | "Workspace";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "actorType_ASC"
  | "actorType_DESC"
  | "targetType_ASC"
  | "targetType_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "lastLogin_ASC"
  | "lastLogin_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "position_ASC"
  | "position_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "size_ASC"
  | "size_DESC"
  | "type_ASC"
  | "type_DESC"
  | "name_ASC"
  | "name_DESC"
  | "url_ASC"
  | "url_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "label_ASC"
  | "label_DESC";

export type FieldLinkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "value_ASC"
  | "value_DESC";

export type TaskOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "dueAt_ASC"
  | "dueAt_DESC";

export type ApplicationOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type StageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "type_ASC"
  | "type_DESC";

export type DisqualificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type FieldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "label_ASC"
  | "label_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "country_ASC"
  | "country_DESC"
  | "region_ASC"
  | "region_DESC"
  | "city_ASC"
  | "city_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type JobOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "department_ASC"
  | "department_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "requirements_ASC"
  | "requirements_DESC";

export type CandidateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "metaCompany_ASC"
  | "metaCompany_DESC"
  | "metaHeadline_ASC"
  | "metaHeadline_DESC"
  | "metaPosition_ASC"
  | "metaPosition_DESC";

export type WorkflowOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type InviteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "expireAt_ASC"
  | "expireAt_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC";

export type DisqualificationLinkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "justification_ASC"
  | "justification_DESC";

export type WorkspaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ApplicationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EventWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: EventType;
  type_not?: EventType;
  type_in?: EventType[] | EventType;
  type_not_in?: EventType[] | EventType;
  actorType?: EventActorType;
  actorType_not?: EventActorType;
  actorType_in?: EventActorType[] | EventActorType;
  actorType_not_in?: EventActorType[] | EventActorType;
  actorUser?: UserWhereInput;
  actorCandidate?: CandidateWhereInput;
  targetType?: EventTargetType;
  targetType_not?: EventTargetType;
  targetType_in?: EventTargetType[] | EventTargetType;
  targetType_not_in?: EventTargetType[] | EventTargetType;
  targetCandidate?: CandidateWhereInput;
  targetJob?: JobWhereInput;
  targetTask?: TaskWhereInput;
  targetWorkspace?: WorkspaceWhereInput;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  workspace?: WorkspaceWhereInput;
  events?: EventWhereInput;
  notifications_every?: NotificationWhereInput;
  notifications_some?: NotificationWhereInput;
  notifications_none?: NotificationWhereInput;
  subscriptionJobs_every?: JobWhereInput;
  subscriptionJobs_some?: JobWhereInput;
  subscriptionJobs_none?: JobWhereInput;
  subscriptionCandidates_every?: CandidateWhereInput;
  subscriptionCandidates_some?: CandidateWhereInput;
  subscriptionCandidates_none?: CandidateWhereInput;
  subscriptionTasks_every?: TaskWhereInput;
  subscriptionTasks_some?: TaskWhereInput;
  subscriptionTasks_none?: TaskWhereInput;
  tasks_every?: TaskWhereInput;
  tasks_some?: TaskWhereInput;
  tasks_none?: TaskWhereInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  lastLogin?: DateTimeInput;
  lastLogin_not?: DateTimeInput;
  lastLogin_in?: DateTimeInput[] | DateTimeInput;
  lastLogin_not_in?: DateTimeInput[] | DateTimeInput;
  lastLogin_lt?: DateTimeInput;
  lastLogin_lte?: DateTimeInput;
  lastLogin_gt?: DateTimeInput;
  lastLogin_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  avatar?: FileWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface WorkspaceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  events_every?: EventWhereInput;
  events_some?: EventWhereInput;
  events_none?: EventWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  jobs_every?: JobWhereInput;
  jobs_some?: JobWhereInput;
  jobs_none?: JobWhereInput;
  candidates_every?: CandidateWhereInput;
  candidates_some?: CandidateWhereInput;
  candidates_none?: CandidateWhereInput;
  workflows_every?: WorkflowWhereInput;
  workflows_some?: WorkflowWhereInput;
  workflows_none?: WorkflowWhereInput;
  workflowDefault?: WorkflowWhereInput;
  invites_every?: InviteWhereInput;
  invites_some?: InviteWhereInput;
  invites_none?: InviteWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: WorkspaceWhereInput[] | WorkspaceWhereInput;
  OR?: WorkspaceWhereInput[] | WorkspaceWhereInput;
  NOT?: WorkspaceWhereInput[] | WorkspaceWhereInput;
}

export interface JobWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  workspace?: WorkspaceWhereInput;
  subscribers_every?: UserWhereInput;
  subscribers_some?: UserWhereInput;
  subscribers_none?: UserWhereInput;
  events_every?: EventWhereInput;
  events_some?: EventWhereInput;
  events_none?: EventWhereInput;
  applications_every?: ApplicationWhereInput;
  applications_some?: ApplicationWhereInput;
  applications_none?: ApplicationWhereInput;
  workflow?: WorkflowWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  type?: JobType;
  type_not?: JobType;
  type_in?: JobType[] | JobType;
  type_not_in?: JobType[] | JobType;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  locations_every?: LocationWhereInput;
  locations_some?: LocationWhereInput;
  locations_none?: LocationWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  requirements?: String;
  requirements_not?: String;
  requirements_in?: String[] | String;
  requirements_not_in?: String[] | String;
  requirements_lt?: String;
  requirements_lte?: String;
  requirements_gt?: String;
  requirements_gte?: String;
  requirements_contains?: String;
  requirements_not_contains?: String;
  requirements_starts_with?: String;
  requirements_not_starts_with?: String;
  requirements_ends_with?: String;
  requirements_not_ends_with?: String;
  AND?: JobWhereInput[] | JobWhereInput;
  OR?: JobWhereInput[] | JobWhereInput;
  NOT?: JobWhereInput[] | JobWhereInput;
}

export interface ApplicationWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: ApplicationType;
  type_not?: ApplicationType;
  type_in?: ApplicationType[] | ApplicationType;
  type_not_in?: ApplicationType[] | ApplicationType;
  disqualificationLink?: DisqualificationLinkWhereInput;
  stage?: StageWhereInput;
  job?: JobWhereInput;
  candidate?: CandidateWhereInput;
  AND?: ApplicationWhereInput[] | ApplicationWhereInput;
  OR?: ApplicationWhereInput[] | ApplicationWhereInput;
  NOT?: ApplicationWhereInput[] | ApplicationWhereInput;
}

export interface DisqualificationLinkWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  disqualification?: DisqualificationWhereInput;
  createdBy?: UserWhereInput;
  justification?: String;
  justification_not?: String;
  justification_in?: String[] | String;
  justification_not_in?: String[] | String;
  justification_lt?: String;
  justification_lte?: String;
  justification_gt?: String;
  justification_gte?: String;
  justification_contains?: String;
  justification_not_contains?: String;
  justification_starts_with?: String;
  justification_not_starts_with?: String;
  justification_ends_with?: String;
  justification_not_ends_with?: String;
  AND?: DisqualificationLinkWhereInput[] | DisqualificationLinkWhereInput;
  OR?: DisqualificationLinkWhereInput[] | DisqualificationLinkWhereInput;
  NOT?: DisqualificationLinkWhereInput[] | DisqualificationLinkWhereInput;
}

export interface DisqualificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: DisqualificationWhereInput[] | DisqualificationWhereInput;
  OR?: DisqualificationWhereInput[] | DisqualificationWhereInput;
  NOT?: DisqualificationWhereInput[] | DisqualificationWhereInput;
}

export interface StageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  type?: StageType;
  type_not?: StageType;
  type_in?: StageType[] | StageType;
  type_not_in?: StageType[] | StageType;
  AND?: StageWhereInput[] | StageWhereInput;
  OR?: StageWhereInput[] | StageWhereInput;
  NOT?: StageWhereInput[] | StageWhereInput;
}

export interface CandidateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  workspace?: WorkspaceWhereInput;
  events_every?: EventWhereInput;
  events_some?: EventWhereInput;
  events_none?: EventWhereInput;
  subscribers_every?: UserWhereInput;
  subscribers_some?: UserWhereInput;
  subscribers_none?: UserWhereInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  avatar?: FileWhereInput;
  metaCompany?: String;
  metaCompany_not?: String;
  metaCompany_in?: String[] | String;
  metaCompany_not_in?: String[] | String;
  metaCompany_lt?: String;
  metaCompany_lte?: String;
  metaCompany_gt?: String;
  metaCompany_gte?: String;
  metaCompany_contains?: String;
  metaCompany_not_contains?: String;
  metaCompany_starts_with?: String;
  metaCompany_not_starts_with?: String;
  metaCompany_ends_with?: String;
  metaCompany_not_ends_with?: String;
  metaHeadline?: String;
  metaHeadline_not?: String;
  metaHeadline_in?: String[] | String;
  metaHeadline_not_in?: String[] | String;
  metaHeadline_lt?: String;
  metaHeadline_lte?: String;
  metaHeadline_gt?: String;
  metaHeadline_gte?: String;
  metaHeadline_contains?: String;
  metaHeadline_not_contains?: String;
  metaHeadline_starts_with?: String;
  metaHeadline_not_starts_with?: String;
  metaHeadline_ends_with?: String;
  metaHeadline_not_ends_with?: String;
  metaPosition?: String;
  metaPosition_not?: String;
  metaPosition_in?: String[] | String;
  metaPosition_not_in?: String[] | String;
  metaPosition_lt?: String;
  metaPosition_lte?: String;
  metaPosition_gt?: String;
  metaPosition_gte?: String;
  metaPosition_contains?: String;
  metaPosition_not_contains?: String;
  metaPosition_starts_with?: String;
  metaPosition_not_starts_with?: String;
  metaPosition_ends_with?: String;
  metaPosition_not_ends_with?: String;
  resumesFile_every?: FileWhereInput;
  resumesFile_some?: FileWhereInput;
  resumesFile_none?: FileWhereInput;
  coverLettersFile_every?: FileWhereInput;
  coverLettersFile_some?: FileWhereInput;
  coverLettersFile_none?: FileWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  fields_every?: FieldLinkWhereInput;
  fields_some?: FieldLinkWhereInput;
  fields_none?: FieldLinkWhereInput;
  tasks_every?: TaskWhereInput;
  tasks_some?: TaskWhereInput;
  tasks_none?: TaskWhereInput;
  applications_every?: ApplicationWhereInput;
  applications_some?: ApplicationWhereInput;
  applications_none?: ApplicationWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  AND?: CandidateWhereInput[] | CandidateWhereInput;
  OR?: CandidateWhereInput[] | CandidateWhereInput;
  NOT?: CandidateWhereInput[] | CandidateWhereInput;
}

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface FieldLinkWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  field?: FieldWhereInput;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: FieldLinkWhereInput[] | FieldLinkWhereInput;
  OR?: FieldLinkWhereInput[] | FieldLinkWhereInput;
  NOT?: FieldLinkWhereInput[] | FieldLinkWhereInput;
}

export interface FieldWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: FieldType;
  type_not?: FieldType;
  type_in?: FieldType[] | FieldType;
  type_not_in?: FieldType[] | FieldType;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  AND?: FieldWhereInput[] | FieldWhereInput;
  OR?: FieldWhereInput[] | FieldWhereInput;
  NOT?: FieldWhereInput[] | FieldWhereInput;
}

export interface TaskWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  subscribers_every?: UserWhereInput;
  subscribers_some?: UserWhereInput;
  subscribers_none?: UserWhereInput;
  owners_every?: UserWhereInput;
  owners_some?: UserWhereInput;
  owners_none?: UserWhereInput;
  candidate?: CandidateWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  dueAt?: DateTimeInput;
  dueAt_not?: DateTimeInput;
  dueAt_in?: DateTimeInput[] | DateTimeInput;
  dueAt_not_in?: DateTimeInput[] | DateTimeInput;
  dueAt_lt?: DateTimeInput;
  dueAt_lte?: DateTimeInput;
  dueAt_gt?: DateTimeInput;
  dueAt_gte?: DateTimeInput;
  AND?: TaskWhereInput[] | TaskWhereInput;
  OR?: TaskWhereInput[] | TaskWhereInput;
  NOT?: TaskWhereInput[] | TaskWhereInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdBy?: UserWhereInput;
  parent?: CommentWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface WorkflowWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  stages_every?: StageWhereInput;
  stages_some?: StageWhereInput;
  stages_none?: StageWhereInput;
  disqualifications_every?: DisqualificationWhereInput;
  disqualifications_some?: DisqualificationWhereInput;
  disqualifications_none?: DisqualificationWhereInput;
  fields_every?: FieldWhereInput;
  fields_some?: FieldWhereInput;
  fields_none?: FieldWhereInput;
  AND?: WorkflowWhereInput[] | WorkflowWhereInput;
  OR?: WorkflowWhereInput[] | WorkflowWhereInput;
  NOT?: WorkflowWhereInput[] | WorkflowWhereInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  region?: String;
  region_not?: String;
  region_in?: String[] | String;
  region_not_in?: String[] | String;
  region_lt?: String;
  region_lte?: String;
  region_gt?: String;
  region_gte?: String;
  region_contains?: String;
  region_not_contains?: String;
  region_starts_with?: String;
  region_not_starts_with?: String;
  region_ends_with?: String;
  region_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  zip?: String;
  zip_not?: String;
  zip_in?: String[] | String;
  zip_not_in?: String[] | String;
  zip_lt?: String;
  zip_lte?: String;
  zip_gt?: String;
  zip_gte?: String;
  zip_contains?: String;
  zip_not_contains?: String;
  zip_starts_with?: String;
  zip_not_starts_with?: String;
  zip_ends_with?: String;
  zip_not_ends_with?: String;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface InviteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  expireAt?: DateTimeInput;
  expireAt_not?: DateTimeInput;
  expireAt_in?: DateTimeInput[] | DateTimeInput;
  expireAt_not_in?: DateTimeInput[] | DateTimeInput;
  expireAt_lt?: DateTimeInput;
  expireAt_lte?: DateTimeInput;
  expireAt_gt?: DateTimeInput;
  expireAt_gte?: DateTimeInput;
  invitedBy?: UserWhereInput;
  AND?: InviteWhereInput[] | InviteWhereInput;
  OR?: InviteWhereInput[] | InviteWhereInput;
  NOT?: InviteWhereInput[] | InviteWhereInput;
}

export interface NotificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: NotificationType;
  type_not?: NotificationType;
  type_in?: NotificationType[] | NotificationType;
  type_not_in?: NotificationType[] | NotificationType;
  user?: UserWhereInput;
  event?: EventWhereInput;
  AND?: NotificationWhereInput[] | NotificationWhereInput;
  OR?: NotificationWhereInput[] | NotificationWhereInput;
  NOT?: NotificationWhereInput[] | NotificationWhereInput;
}

export type CandidateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type DisqualificationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type DisqualificationLinkWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FieldWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FieldLinkWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export type InviteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type JobWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type StageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TaskWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export type WorkflowWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type WorkspaceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ApplicationCreateInput {
  type: ApplicationType;
  disqualificationLink?: DisqualificationLinkCreateOneInput;
  stage: StageCreateOneInput;
  job: JobCreateOneWithoutApplicationsInput;
  candidate: CandidateCreateOneWithoutApplicationsInput;
}

export interface DisqualificationLinkCreateOneInput {
  create?: DisqualificationLinkCreateInput;
  connect?: DisqualificationLinkWhereUniqueInput;
}

export interface DisqualificationLinkCreateInput {
  disqualification: DisqualificationCreateOneInput;
  createdBy: UserCreateOneInput;
  justification?: String;
}

export interface DisqualificationCreateOneInput {
  create?: DisqualificationCreateInput;
  connect?: DisqualificationWhereUniqueInput;
}

export interface DisqualificationCreateInput {
  name: String;
  description?: String;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  workspace: WorkspaceCreateOneWithoutUsersInput;
  events?: EventCreateOneWithoutActorUserInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  subscriptionJobs?: JobCreateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateCreateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskCreateManyWithoutSubscribersInput;
  tasks?: TaskCreateManyWithoutOwnersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface WorkspaceCreateOneWithoutUsersInput {
  create?: WorkspaceCreateWithoutUsersInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceCreateWithoutUsersInput {
  events?: EventCreateManyWithoutTargetWorkspaceInput;
  jobs?: JobCreateManyWithoutWorkspaceInput;
  candidates?: CandidateCreateManyWithoutWorkspaceInput;
  workflows?: WorkflowCreateManyInput;
  workflowDefault?: WorkflowCreateOneInput;
  invites?: InviteCreateManyInput;
  tags?: TagCreateManyInput;
  name: String;
}

export interface EventCreateManyWithoutTargetWorkspaceInput {
  create?:
    | EventCreateWithoutTargetWorkspaceInput[]
    | EventCreateWithoutTargetWorkspaceInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface EventCreateWithoutTargetWorkspaceInput {
  type: EventType;
  actorType: EventActorType;
  actorUser?: UserCreateOneWithoutEventsInput;
  actorCandidate?: CandidateCreateOneInput;
  targetType: EventTargetType;
  targetCandidate?: CandidateCreateOneWithoutEventsInput;
  targetJob?: JobCreateOneWithoutEventsInput;
  targetTask?: TaskCreateOneInput;
}

export interface UserCreateOneWithoutEventsInput {
  create?: UserCreateWithoutEventsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutEventsInput {
  workspace: WorkspaceCreateOneWithoutUsersInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  subscriptionJobs?: JobCreateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateCreateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskCreateManyWithoutSubscribersInput;
  tasks?: TaskCreateManyWithoutOwnersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface NotificationCreateManyWithoutUserInput {
  create?:
    | NotificationCreateWithoutUserInput[]
    | NotificationCreateWithoutUserInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
}

export interface NotificationCreateWithoutUserInput {
  type: NotificationType;
  event: EventCreateOneInput;
}

export interface EventCreateOneInput {
  create?: EventCreateInput;
  connect?: EventWhereUniqueInput;
}

export interface EventCreateInput {
  type: EventType;
  actorType: EventActorType;
  actorUser?: UserCreateOneWithoutEventsInput;
  actorCandidate?: CandidateCreateOneInput;
  targetType: EventTargetType;
  targetCandidate?: CandidateCreateOneWithoutEventsInput;
  targetJob?: JobCreateOneWithoutEventsInput;
  targetTask?: TaskCreateOneInput;
  targetWorkspace?: WorkspaceCreateOneWithoutEventsInput;
}

export interface CandidateCreateOneInput {
  create?: CandidateCreateInput;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateCreateInput {
  workspace: WorkspaceCreateOneWithoutCandidatesInput;
  events?: EventCreateManyWithoutTargetCandidateInput;
  subscribers?: UserCreateManyWithoutSubscriptionCandidatesInput;
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  source?: CandidateCreatesourceInput;
  fields?: FieldLinkCreateManyInput;
  tasks?: TaskCreateManyWithoutCandidateInput;
  applications?: ApplicationCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface WorkspaceCreateOneWithoutCandidatesInput {
  create?: WorkspaceCreateWithoutCandidatesInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceCreateWithoutCandidatesInput {
  events?: EventCreateManyWithoutTargetWorkspaceInput;
  users?: UserCreateManyWithoutWorkspaceInput;
  jobs?: JobCreateManyWithoutWorkspaceInput;
  workflows?: WorkflowCreateManyInput;
  workflowDefault?: WorkflowCreateOneInput;
  invites?: InviteCreateManyInput;
  tags?: TagCreateManyInput;
  name: String;
}

export interface UserCreateManyWithoutWorkspaceInput {
  create?: UserCreateWithoutWorkspaceInput[] | UserCreateWithoutWorkspaceInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutWorkspaceInput {
  events?: EventCreateOneWithoutActorUserInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  subscriptionJobs?: JobCreateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateCreateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskCreateManyWithoutSubscribersInput;
  tasks?: TaskCreateManyWithoutOwnersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface EventCreateOneWithoutActorUserInput {
  create?: EventCreateWithoutActorUserInput;
  connect?: EventWhereUniqueInput;
}

export interface EventCreateWithoutActorUserInput {
  type: EventType;
  actorType: EventActorType;
  actorCandidate?: CandidateCreateOneInput;
  targetType: EventTargetType;
  targetCandidate?: CandidateCreateOneWithoutEventsInput;
  targetJob?: JobCreateOneWithoutEventsInput;
  targetTask?: TaskCreateOneInput;
  targetWorkspace?: WorkspaceCreateOneWithoutEventsInput;
}

export interface CandidateCreateOneWithoutEventsInput {
  create?: CandidateCreateWithoutEventsInput;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateCreateWithoutEventsInput {
  workspace: WorkspaceCreateOneWithoutCandidatesInput;
  subscribers?: UserCreateManyWithoutSubscriptionCandidatesInput;
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  source?: CandidateCreatesourceInput;
  fields?: FieldLinkCreateManyInput;
  tasks?: TaskCreateManyWithoutCandidateInput;
  applications?: ApplicationCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface UserCreateManyWithoutSubscriptionCandidatesInput {
  create?:
    | UserCreateWithoutSubscriptionCandidatesInput[]
    | UserCreateWithoutSubscriptionCandidatesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutSubscriptionCandidatesInput {
  workspace: WorkspaceCreateOneWithoutUsersInput;
  events?: EventCreateOneWithoutActorUserInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  subscriptionJobs?: JobCreateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskCreateManyWithoutSubscribersInput;
  tasks?: TaskCreateManyWithoutOwnersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface JobCreateManyWithoutSubscribersInput {
  create?:
    | JobCreateWithoutSubscribersInput[]
    | JobCreateWithoutSubscribersInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
}

export interface JobCreateWithoutSubscribersInput {
  workspace: WorkspaceCreateOneWithoutJobsInput;
  events?: EventCreateManyWithoutTargetJobInput;
  applications?: ApplicationCreateManyWithoutJobInput;
  workflow: WorkflowCreateOneInput;
  comments?: CommentCreateManyInput;
  type: JobType;
  department?: String;
  locations?: LocationCreateManyInput;
  name: String;
  description?: String;
  requirements?: String;
}

export interface WorkspaceCreateOneWithoutJobsInput {
  create?: WorkspaceCreateWithoutJobsInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceCreateWithoutJobsInput {
  events?: EventCreateManyWithoutTargetWorkspaceInput;
  users?: UserCreateManyWithoutWorkspaceInput;
  candidates?: CandidateCreateManyWithoutWorkspaceInput;
  workflows?: WorkflowCreateManyInput;
  workflowDefault?: WorkflowCreateOneInput;
  invites?: InviteCreateManyInput;
  tags?: TagCreateManyInput;
  name: String;
}

export interface CandidateCreateManyWithoutWorkspaceInput {
  create?:
    | CandidateCreateWithoutWorkspaceInput[]
    | CandidateCreateWithoutWorkspaceInput;
  connect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
}

export interface CandidateCreateWithoutWorkspaceInput {
  events?: EventCreateManyWithoutTargetCandidateInput;
  subscribers?: UserCreateManyWithoutSubscriptionCandidatesInput;
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  source?: CandidateCreatesourceInput;
  fields?: FieldLinkCreateManyInput;
  tasks?: TaskCreateManyWithoutCandidateInput;
  applications?: ApplicationCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface EventCreateManyWithoutTargetCandidateInput {
  create?:
    | EventCreateWithoutTargetCandidateInput[]
    | EventCreateWithoutTargetCandidateInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface EventCreateWithoutTargetCandidateInput {
  type: EventType;
  actorType: EventActorType;
  actorUser?: UserCreateOneWithoutEventsInput;
  actorCandidate?: CandidateCreateOneInput;
  targetType: EventTargetType;
  targetJob?: JobCreateOneWithoutEventsInput;
  targetTask?: TaskCreateOneInput;
  targetWorkspace?: WorkspaceCreateOneWithoutEventsInput;
}

export interface JobCreateOneWithoutEventsInput {
  create?: JobCreateWithoutEventsInput;
  connect?: JobWhereUniqueInput;
}

export interface JobCreateWithoutEventsInput {
  workspace: WorkspaceCreateOneWithoutJobsInput;
  subscribers?: UserCreateManyWithoutSubscriptionJobsInput;
  applications?: ApplicationCreateManyWithoutJobInput;
  workflow: WorkflowCreateOneInput;
  comments?: CommentCreateManyInput;
  type: JobType;
  department?: String;
  locations?: LocationCreateManyInput;
  name: String;
  description?: String;
  requirements?: String;
}

export interface UserCreateManyWithoutSubscriptionJobsInput {
  create?:
    | UserCreateWithoutSubscriptionJobsInput[]
    | UserCreateWithoutSubscriptionJobsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutSubscriptionJobsInput {
  workspace: WorkspaceCreateOneWithoutUsersInput;
  events?: EventCreateOneWithoutActorUserInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  subscriptionCandidates?: CandidateCreateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskCreateManyWithoutSubscribersInput;
  tasks?: TaskCreateManyWithoutOwnersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface CandidateCreateManyWithoutSubscribersInput {
  create?:
    | CandidateCreateWithoutSubscribersInput[]
    | CandidateCreateWithoutSubscribersInput;
  connect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
}

export interface CandidateCreateWithoutSubscribersInput {
  workspace: WorkspaceCreateOneWithoutCandidatesInput;
  events?: EventCreateManyWithoutTargetCandidateInput;
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  source?: CandidateCreatesourceInput;
  fields?: FieldLinkCreateManyInput;
  tasks?: TaskCreateManyWithoutCandidateInput;
  applications?: ApplicationCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface CandidateCreateemailsInput {
  set?: String[] | String;
}

export interface CandidateCreatephonesInput {
  set?: String[] | String;
}

export interface CandidateCreatelinksInput {
  set?: String[] | String;
}

export interface FileCreateOneInput {
  create?: FileCreateInput;
  connect?: FileWhereUniqueInput;
}

export interface FileCreateInput {
  size: Int;
  type: String;
  name: String;
  url: String;
}

export interface CandidateCreateresumesStringInput {
  set?: String[] | String;
}

export interface FileCreateManyInput {
  create?: FileCreateInput[] | FileCreateInput;
  connect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
}

export interface CandidateCreatecoverLettersStringInput {
  set?: String[] | String;
}

export interface TagCreateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface TagCreateInput {
  label: String;
}

export interface CandidateCreatesourceInput {
  set?: String[] | String;
}

export interface FieldLinkCreateManyInput {
  create?: FieldLinkCreateInput[] | FieldLinkCreateInput;
  connect?: FieldLinkWhereUniqueInput[] | FieldLinkWhereUniqueInput;
}

export interface FieldLinkCreateInput {
  field: FieldCreateOneInput;
  value?: String;
}

export interface FieldCreateOneInput {
  create?: FieldCreateInput;
  connect?: FieldWhereUniqueInput;
}

export interface FieldCreateInput {
  type: FieldType;
  label: String;
}

export interface TaskCreateManyWithoutCandidateInput {
  create?: TaskCreateWithoutCandidateInput[] | TaskCreateWithoutCandidateInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
}

export interface TaskCreateWithoutCandidateInput {
  subscribers?: UserCreateManyWithoutSubscriptionTasksInput;
  owners?: UserCreateManyWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserCreateManyWithoutSubscriptionTasksInput {
  create?:
    | UserCreateWithoutSubscriptionTasksInput[]
    | UserCreateWithoutSubscriptionTasksInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutSubscriptionTasksInput {
  workspace: WorkspaceCreateOneWithoutUsersInput;
  events?: EventCreateOneWithoutActorUserInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  subscriptionJobs?: JobCreateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateCreateManyWithoutSubscribersInput;
  tasks?: TaskCreateManyWithoutOwnersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface TaskCreateManyWithoutOwnersInput {
  create?: TaskCreateWithoutOwnersInput[] | TaskCreateWithoutOwnersInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
}

export interface TaskCreateWithoutOwnersInput {
  subscribers?: UserCreateManyWithoutSubscriptionTasksInput;
  candidate?: CandidateCreateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface CandidateCreateOneWithoutTasksInput {
  create?: CandidateCreateWithoutTasksInput;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateCreateWithoutTasksInput {
  workspace: WorkspaceCreateOneWithoutCandidatesInput;
  events?: EventCreateManyWithoutTargetCandidateInput;
  subscribers?: UserCreateManyWithoutSubscriptionCandidatesInput;
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  source?: CandidateCreatesourceInput;
  fields?: FieldLinkCreateManyInput;
  applications?: ApplicationCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface ApplicationCreateManyWithoutCandidateInput {
  create?:
    | ApplicationCreateWithoutCandidateInput[]
    | ApplicationCreateWithoutCandidateInput;
  connect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
}

export interface ApplicationCreateWithoutCandidateInput {
  type: ApplicationType;
  disqualificationLink?: DisqualificationLinkCreateOneInput;
  stage: StageCreateOneInput;
  job: JobCreateOneWithoutApplicationsInput;
}

export interface StageCreateOneInput {
  create?: StageCreateInput;
  connect?: StageWhereUniqueInput;
}

export interface StageCreateInput {
  name: String;
  description?: String;
  type: StageType;
}

export interface JobCreateOneWithoutApplicationsInput {
  create?: JobCreateWithoutApplicationsInput;
  connect?: JobWhereUniqueInput;
}

export interface JobCreateWithoutApplicationsInput {
  workspace: WorkspaceCreateOneWithoutJobsInput;
  subscribers?: UserCreateManyWithoutSubscriptionJobsInput;
  events?: EventCreateManyWithoutTargetJobInput;
  workflow: WorkflowCreateOneInput;
  comments?: CommentCreateManyInput;
  type: JobType;
  department?: String;
  locations?: LocationCreateManyInput;
  name: String;
  description?: String;
  requirements?: String;
}

export interface EventCreateManyWithoutTargetJobInput {
  create?:
    | EventCreateWithoutTargetJobInput[]
    | EventCreateWithoutTargetJobInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface EventCreateWithoutTargetJobInput {
  type: EventType;
  actorType: EventActorType;
  actorUser?: UserCreateOneWithoutEventsInput;
  actorCandidate?: CandidateCreateOneInput;
  targetType: EventTargetType;
  targetCandidate?: CandidateCreateOneWithoutEventsInput;
  targetTask?: TaskCreateOneInput;
  targetWorkspace?: WorkspaceCreateOneWithoutEventsInput;
}

export interface TaskCreateOneInput {
  create?: TaskCreateInput;
  connect?: TaskWhereUniqueInput;
}

export interface TaskCreateInput {
  subscribers?: UserCreateManyWithoutSubscriptionTasksInput;
  owners?: UserCreateManyWithoutTasksInput;
  candidate?: CandidateCreateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserCreateManyWithoutTasksInput {
  create?: UserCreateWithoutTasksInput[] | UserCreateWithoutTasksInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutTasksInput {
  workspace: WorkspaceCreateOneWithoutUsersInput;
  events?: EventCreateOneWithoutActorUserInput;
  notifications?: NotificationCreateManyWithoutUserInput;
  subscriptionJobs?: JobCreateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateCreateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskCreateManyWithoutSubscribersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface TaskCreateManyWithoutSubscribersInput {
  create?:
    | TaskCreateWithoutSubscribersInput[]
    | TaskCreateWithoutSubscribersInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
}

export interface TaskCreateWithoutSubscribersInput {
  owners?: UserCreateManyWithoutTasksInput;
  candidate?: CandidateCreateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface WorkspaceCreateOneWithoutEventsInput {
  create?: WorkspaceCreateWithoutEventsInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceCreateWithoutEventsInput {
  users?: UserCreateManyWithoutWorkspaceInput;
  jobs?: JobCreateManyWithoutWorkspaceInput;
  candidates?: CandidateCreateManyWithoutWorkspaceInput;
  workflows?: WorkflowCreateManyInput;
  workflowDefault?: WorkflowCreateOneInput;
  invites?: InviteCreateManyInput;
  tags?: TagCreateManyInput;
  name: String;
}

export interface JobCreateManyWithoutWorkspaceInput {
  create?: JobCreateWithoutWorkspaceInput[] | JobCreateWithoutWorkspaceInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
}

export interface JobCreateWithoutWorkspaceInput {
  subscribers?: UserCreateManyWithoutSubscriptionJobsInput;
  events?: EventCreateManyWithoutTargetJobInput;
  applications?: ApplicationCreateManyWithoutJobInput;
  workflow: WorkflowCreateOneInput;
  comments?: CommentCreateManyInput;
  type: JobType;
  department?: String;
  locations?: LocationCreateManyInput;
  name: String;
  description?: String;
  requirements?: String;
}

export interface ApplicationCreateManyWithoutJobInput {
  create?:
    | ApplicationCreateWithoutJobInput[]
    | ApplicationCreateWithoutJobInput;
  connect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
}

export interface ApplicationCreateWithoutJobInput {
  type: ApplicationType;
  disqualificationLink?: DisqualificationLinkCreateOneInput;
  stage: StageCreateOneInput;
  candidate: CandidateCreateOneWithoutApplicationsInput;
}

export interface CandidateCreateOneWithoutApplicationsInput {
  create?: CandidateCreateWithoutApplicationsInput;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateCreateWithoutApplicationsInput {
  workspace: WorkspaceCreateOneWithoutCandidatesInput;
  events?: EventCreateManyWithoutTargetCandidateInput;
  subscribers?: UserCreateManyWithoutSubscriptionCandidatesInput;
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  source?: CandidateCreatesourceInput;
  fields?: FieldLinkCreateManyInput;
  tasks?: TaskCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface CommentCreateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateInput {
  createdBy: UserCreateOneInput;
  parent?: CommentCreateOneInput;
  content: String;
}

export interface CommentCreateOneInput {
  create?: CommentCreateInput;
  connect?: CommentWhereUniqueInput;
}

export interface WorkflowCreateOneInput {
  create?: WorkflowCreateInput;
  connect?: WorkflowWhereUniqueInput;
}

export interface WorkflowCreateInput {
  name: String;
  description?: String;
  stages?: StageCreateManyInput;
  disqualifications?: DisqualificationCreateManyInput;
  fields?: FieldCreateManyInput;
}

export interface StageCreateManyInput {
  create?: StageCreateInput[] | StageCreateInput;
  connect?: StageWhereUniqueInput[] | StageWhereUniqueInput;
}

export interface DisqualificationCreateManyInput {
  create?: DisqualificationCreateInput[] | DisqualificationCreateInput;
  connect?:
    | DisqualificationWhereUniqueInput[]
    | DisqualificationWhereUniqueInput;
}

export interface FieldCreateManyInput {
  create?: FieldCreateInput[] | FieldCreateInput;
  connect?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
}

export interface LocationCreateManyInput {
  create?: LocationCreateInput[] | LocationCreateInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
}

export interface LocationCreateInput {
  country: String;
  region: String;
  city: String;
  zip: String;
}

export interface WorkflowCreateManyInput {
  create?: WorkflowCreateInput[] | WorkflowCreateInput;
  connect?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
}

export interface InviteCreateManyInput {
  create?: InviteCreateInput[] | InviteCreateInput;
  connect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
}

export interface InviteCreateInput {
  email: String;
  expireAt: DateTimeInput;
  invitedBy: UserCreateOneInput;
}

export interface ApplicationUpdateInput {
  type?: ApplicationType;
  disqualificationLink?: DisqualificationLinkUpdateOneInput;
  stage?: StageUpdateOneRequiredInput;
  job?: JobUpdateOneRequiredWithoutApplicationsInput;
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput;
}

export interface DisqualificationLinkUpdateOneInput {
  create?: DisqualificationLinkCreateInput;
  update?: DisqualificationLinkUpdateDataInput;
  upsert?: DisqualificationLinkUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DisqualificationLinkWhereUniqueInput;
}

export interface DisqualificationLinkUpdateDataInput {
  disqualification?: DisqualificationUpdateOneRequiredInput;
  createdBy?: UserUpdateOneRequiredInput;
  justification?: String;
}

export interface DisqualificationUpdateOneRequiredInput {
  create?: DisqualificationCreateInput;
  update?: DisqualificationUpdateDataInput;
  upsert?: DisqualificationUpsertNestedInput;
  connect?: DisqualificationWhereUniqueInput;
}

export interface DisqualificationUpdateDataInput {
  name?: String;
  description?: String;
}

export interface DisqualificationUpsertNestedInput {
  update: DisqualificationUpdateDataInput;
  create: DisqualificationCreateInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput;
  events?: EventUpdateOneWithoutActorUserInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  subscriptionJobs?: JobUpdateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateUpdateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskUpdateManyWithoutSubscribersInput;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface WorkspaceUpdateOneRequiredWithoutUsersInput {
  create?: WorkspaceCreateWithoutUsersInput;
  update?: WorkspaceUpdateWithoutUsersDataInput;
  upsert?: WorkspaceUpsertWithoutUsersInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceUpdateWithoutUsersDataInput {
  events?: EventUpdateManyWithoutTargetWorkspaceInput;
  jobs?: JobUpdateManyWithoutWorkspaceInput;
  candidates?: CandidateUpdateManyWithoutWorkspaceInput;
  workflows?: WorkflowUpdateManyInput;
  workflowDefault?: WorkflowUpdateOneInput;
  invites?: InviteUpdateManyInput;
  tags?: TagUpdateManyInput;
  name?: String;
}

export interface EventUpdateManyWithoutTargetWorkspaceInput {
  create?:
    | EventCreateWithoutTargetWorkspaceInput[]
    | EventCreateWithoutTargetWorkspaceInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutTargetWorkspaceInput[]
    | EventUpdateWithWhereUniqueWithoutTargetWorkspaceInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutTargetWorkspaceInput[]
    | EventUpsertWithWhereUniqueWithoutTargetWorkspaceInput;
  deleteMany?: EventScalarWhereInput[] | EventScalarWhereInput;
  updateMany?:
    | EventUpdateManyWithWhereNestedInput[]
    | EventUpdateManyWithWhereNestedInput;
}

export interface EventUpdateWithWhereUniqueWithoutTargetWorkspaceInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutTargetWorkspaceDataInput;
}

export interface EventUpdateWithoutTargetWorkspaceDataInput {
  type?: EventType;
  actorType?: EventActorType;
  actorUser?: UserUpdateOneWithoutEventsInput;
  actorCandidate?: CandidateUpdateOneInput;
  targetType?: EventTargetType;
  targetCandidate?: CandidateUpdateOneWithoutEventsInput;
  targetJob?: JobUpdateOneWithoutEventsInput;
  targetTask?: TaskUpdateOneInput;
}

export interface UserUpdateOneWithoutEventsInput {
  create?: UserCreateWithoutEventsInput;
  update?: UserUpdateWithoutEventsDataInput;
  upsert?: UserUpsertWithoutEventsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutEventsDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  subscriptionJobs?: JobUpdateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateUpdateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskUpdateManyWithoutSubscribersInput;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface NotificationUpdateManyWithoutUserInput {
  create?:
    | NotificationCreateWithoutUserInput[]
    | NotificationCreateWithoutUserInput;
  delete?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  connect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  disconnect?: NotificationWhereUniqueInput[] | NotificationWhereUniqueInput;
  update?:
    | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    | NotificationUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    | NotificationUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  updateMany?:
    | NotificationUpdateManyWithWhereNestedInput[]
    | NotificationUpdateManyWithWhereNestedInput;
}

export interface NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateWithoutUserDataInput;
}

export interface NotificationUpdateWithoutUserDataInput {
  type?: NotificationType;
  event?: EventUpdateOneRequiredInput;
}

export interface EventUpdateOneRequiredInput {
  create?: EventCreateInput;
  update?: EventUpdateDataInput;
  upsert?: EventUpsertNestedInput;
  connect?: EventWhereUniqueInput;
}

export interface EventUpdateDataInput {
  type?: EventType;
  actorType?: EventActorType;
  actorUser?: UserUpdateOneWithoutEventsInput;
  actorCandidate?: CandidateUpdateOneInput;
  targetType?: EventTargetType;
  targetCandidate?: CandidateUpdateOneWithoutEventsInput;
  targetJob?: JobUpdateOneWithoutEventsInput;
  targetTask?: TaskUpdateOneInput;
  targetWorkspace?: WorkspaceUpdateOneWithoutEventsInput;
}

export interface CandidateUpdateOneInput {
  create?: CandidateCreateInput;
  update?: CandidateUpdateDataInput;
  upsert?: CandidateUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateUpdateDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput;
  events?: EventUpdateManyWithoutTargetCandidateInput;
  subscribers?: UserUpdateManyWithoutSubscriptionCandidatesInput;
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  source?: CandidateUpdatesourceInput;
  fields?: FieldLinkUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface WorkspaceUpdateOneRequiredWithoutCandidatesInput {
  create?: WorkspaceCreateWithoutCandidatesInput;
  update?: WorkspaceUpdateWithoutCandidatesDataInput;
  upsert?: WorkspaceUpsertWithoutCandidatesInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceUpdateWithoutCandidatesDataInput {
  events?: EventUpdateManyWithoutTargetWorkspaceInput;
  users?: UserUpdateManyWithoutWorkspaceInput;
  jobs?: JobUpdateManyWithoutWorkspaceInput;
  workflows?: WorkflowUpdateManyInput;
  workflowDefault?: WorkflowUpdateOneInput;
  invites?: InviteUpdateManyInput;
  tags?: TagUpdateManyInput;
  name?: String;
}

export interface UserUpdateManyWithoutWorkspaceInput {
  create?: UserCreateWithoutWorkspaceInput[] | UserCreateWithoutWorkspaceInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutWorkspaceInput[]
    | UserUpdateWithWhereUniqueWithoutWorkspaceInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutWorkspaceInput[]
    | UserUpsertWithWhereUniqueWithoutWorkspaceInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutWorkspaceInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutWorkspaceDataInput;
}

export interface UserUpdateWithoutWorkspaceDataInput {
  events?: EventUpdateOneWithoutActorUserInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  subscriptionJobs?: JobUpdateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateUpdateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskUpdateManyWithoutSubscribersInput;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface EventUpdateOneWithoutActorUserInput {
  create?: EventCreateWithoutActorUserInput;
  update?: EventUpdateWithoutActorUserDataInput;
  upsert?: EventUpsertWithoutActorUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EventWhereUniqueInput;
}

export interface EventUpdateWithoutActorUserDataInput {
  type?: EventType;
  actorType?: EventActorType;
  actorCandidate?: CandidateUpdateOneInput;
  targetType?: EventTargetType;
  targetCandidate?: CandidateUpdateOneWithoutEventsInput;
  targetJob?: JobUpdateOneWithoutEventsInput;
  targetTask?: TaskUpdateOneInput;
  targetWorkspace?: WorkspaceUpdateOneWithoutEventsInput;
}

export interface CandidateUpdateOneWithoutEventsInput {
  create?: CandidateCreateWithoutEventsInput;
  update?: CandidateUpdateWithoutEventsDataInput;
  upsert?: CandidateUpsertWithoutEventsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateUpdateWithoutEventsDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput;
  subscribers?: UserUpdateManyWithoutSubscriptionCandidatesInput;
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  source?: CandidateUpdatesourceInput;
  fields?: FieldLinkUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface UserUpdateManyWithoutSubscriptionCandidatesInput {
  create?:
    | UserCreateWithoutSubscriptionCandidatesInput[]
    | UserCreateWithoutSubscriptionCandidatesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSubscriptionCandidatesInput[]
    | UserUpdateWithWhereUniqueWithoutSubscriptionCandidatesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSubscriptionCandidatesInput[]
    | UserUpsertWithWhereUniqueWithoutSubscriptionCandidatesInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutSubscriptionCandidatesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSubscriptionCandidatesDataInput;
}

export interface UserUpdateWithoutSubscriptionCandidatesDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput;
  events?: EventUpdateOneWithoutActorUserInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  subscriptionJobs?: JobUpdateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskUpdateManyWithoutSubscribersInput;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface JobUpdateManyWithoutSubscribersInput {
  create?:
    | JobCreateWithoutSubscribersInput[]
    | JobCreateWithoutSubscribersInput;
  delete?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  disconnect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  update?:
    | JobUpdateWithWhereUniqueWithoutSubscribersInput[]
    | JobUpdateWithWhereUniqueWithoutSubscribersInput;
  upsert?:
    | JobUpsertWithWhereUniqueWithoutSubscribersInput[]
    | JobUpsertWithWhereUniqueWithoutSubscribersInput;
  deleteMany?: JobScalarWhereInput[] | JobScalarWhereInput;
  updateMany?:
    | JobUpdateManyWithWhereNestedInput[]
    | JobUpdateManyWithWhereNestedInput;
}

export interface JobUpdateWithWhereUniqueWithoutSubscribersInput {
  where: JobWhereUniqueInput;
  data: JobUpdateWithoutSubscribersDataInput;
}

export interface JobUpdateWithoutSubscribersDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutJobsInput;
  events?: EventUpdateManyWithoutTargetJobInput;
  applications?: ApplicationUpdateManyWithoutJobInput;
  workflow?: WorkflowUpdateOneRequiredInput;
  comments?: CommentUpdateManyInput;
  type?: JobType;
  department?: String;
  locations?: LocationUpdateManyInput;
  name?: String;
  description?: String;
  requirements?: String;
}

export interface WorkspaceUpdateOneRequiredWithoutJobsInput {
  create?: WorkspaceCreateWithoutJobsInput;
  update?: WorkspaceUpdateWithoutJobsDataInput;
  upsert?: WorkspaceUpsertWithoutJobsInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceUpdateWithoutJobsDataInput {
  events?: EventUpdateManyWithoutTargetWorkspaceInput;
  users?: UserUpdateManyWithoutWorkspaceInput;
  candidates?: CandidateUpdateManyWithoutWorkspaceInput;
  workflows?: WorkflowUpdateManyInput;
  workflowDefault?: WorkflowUpdateOneInput;
  invites?: InviteUpdateManyInput;
  tags?: TagUpdateManyInput;
  name?: String;
}

export interface CandidateUpdateManyWithoutWorkspaceInput {
  create?:
    | CandidateCreateWithoutWorkspaceInput[]
    | CandidateCreateWithoutWorkspaceInput;
  delete?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  connect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  disconnect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  update?:
    | CandidateUpdateWithWhereUniqueWithoutWorkspaceInput[]
    | CandidateUpdateWithWhereUniqueWithoutWorkspaceInput;
  upsert?:
    | CandidateUpsertWithWhereUniqueWithoutWorkspaceInput[]
    | CandidateUpsertWithWhereUniqueWithoutWorkspaceInput;
  deleteMany?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
  updateMany?:
    | CandidateUpdateManyWithWhereNestedInput[]
    | CandidateUpdateManyWithWhereNestedInput;
}

export interface CandidateUpdateWithWhereUniqueWithoutWorkspaceInput {
  where: CandidateWhereUniqueInput;
  data: CandidateUpdateWithoutWorkspaceDataInput;
}

export interface CandidateUpdateWithoutWorkspaceDataInput {
  events?: EventUpdateManyWithoutTargetCandidateInput;
  subscribers?: UserUpdateManyWithoutSubscriptionCandidatesInput;
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  source?: CandidateUpdatesourceInput;
  fields?: FieldLinkUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface EventUpdateManyWithoutTargetCandidateInput {
  create?:
    | EventCreateWithoutTargetCandidateInput[]
    | EventCreateWithoutTargetCandidateInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutTargetCandidateInput[]
    | EventUpdateWithWhereUniqueWithoutTargetCandidateInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutTargetCandidateInput[]
    | EventUpsertWithWhereUniqueWithoutTargetCandidateInput;
  deleteMany?: EventScalarWhereInput[] | EventScalarWhereInput;
  updateMany?:
    | EventUpdateManyWithWhereNestedInput[]
    | EventUpdateManyWithWhereNestedInput;
}

export interface EventUpdateWithWhereUniqueWithoutTargetCandidateInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutTargetCandidateDataInput;
}

export interface EventUpdateWithoutTargetCandidateDataInput {
  type?: EventType;
  actorType?: EventActorType;
  actorUser?: UserUpdateOneWithoutEventsInput;
  actorCandidate?: CandidateUpdateOneInput;
  targetType?: EventTargetType;
  targetJob?: JobUpdateOneWithoutEventsInput;
  targetTask?: TaskUpdateOneInput;
  targetWorkspace?: WorkspaceUpdateOneWithoutEventsInput;
}

export interface JobUpdateOneWithoutEventsInput {
  create?: JobCreateWithoutEventsInput;
  update?: JobUpdateWithoutEventsDataInput;
  upsert?: JobUpsertWithoutEventsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: JobWhereUniqueInput;
}

export interface JobUpdateWithoutEventsDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutJobsInput;
  subscribers?: UserUpdateManyWithoutSubscriptionJobsInput;
  applications?: ApplicationUpdateManyWithoutJobInput;
  workflow?: WorkflowUpdateOneRequiredInput;
  comments?: CommentUpdateManyInput;
  type?: JobType;
  department?: String;
  locations?: LocationUpdateManyInput;
  name?: String;
  description?: String;
  requirements?: String;
}

export interface UserUpdateManyWithoutSubscriptionJobsInput {
  create?:
    | UserCreateWithoutSubscriptionJobsInput[]
    | UserCreateWithoutSubscriptionJobsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSubscriptionJobsInput[]
    | UserUpdateWithWhereUniqueWithoutSubscriptionJobsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSubscriptionJobsInput[]
    | UserUpsertWithWhereUniqueWithoutSubscriptionJobsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutSubscriptionJobsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSubscriptionJobsDataInput;
}

export interface UserUpdateWithoutSubscriptionJobsDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput;
  events?: EventUpdateOneWithoutActorUserInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  subscriptionCandidates?: CandidateUpdateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskUpdateManyWithoutSubscribersInput;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface CandidateUpdateManyWithoutSubscribersInput {
  create?:
    | CandidateCreateWithoutSubscribersInput[]
    | CandidateCreateWithoutSubscribersInput;
  delete?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  connect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  disconnect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  update?:
    | CandidateUpdateWithWhereUniqueWithoutSubscribersInput[]
    | CandidateUpdateWithWhereUniqueWithoutSubscribersInput;
  upsert?:
    | CandidateUpsertWithWhereUniqueWithoutSubscribersInput[]
    | CandidateUpsertWithWhereUniqueWithoutSubscribersInput;
  deleteMany?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
  updateMany?:
    | CandidateUpdateManyWithWhereNestedInput[]
    | CandidateUpdateManyWithWhereNestedInput;
}

export interface CandidateUpdateWithWhereUniqueWithoutSubscribersInput {
  where: CandidateWhereUniqueInput;
  data: CandidateUpdateWithoutSubscribersDataInput;
}

export interface CandidateUpdateWithoutSubscribersDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput;
  events?: EventUpdateManyWithoutTargetCandidateInput;
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  source?: CandidateUpdatesourceInput;
  fields?: FieldLinkUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface CandidateUpdateemailsInput {
  set?: String[] | String;
}

export interface CandidateUpdatephonesInput {
  set?: String[] | String;
}

export interface CandidateUpdatelinksInput {
  set?: String[] | String;
}

export interface FileUpdateOneInput {
  create?: FileCreateInput;
  update?: FileUpdateDataInput;
  upsert?: FileUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FileWhereUniqueInput;
}

export interface FileUpdateDataInput {
  size?: Int;
  type?: String;
  name?: String;
  url?: String;
}

export interface FileUpsertNestedInput {
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface CandidateUpdateresumesStringInput {
  set?: String[] | String;
}

export interface FileUpdateManyInput {
  create?: FileCreateInput[] | FileCreateInput;
  update?:
    | FileUpdateWithWhereUniqueNestedInput[]
    | FileUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FileUpsertWithWhereUniqueNestedInput[]
    | FileUpsertWithWhereUniqueNestedInput;
  delete?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  connect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  disconnect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  deleteMany?: FileScalarWhereInput[] | FileScalarWhereInput;
  updateMany?:
    | FileUpdateManyWithWhereNestedInput[]
    | FileUpdateManyWithWhereNestedInput;
}

export interface FileUpdateWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  data: FileUpdateDataInput;
}

export interface FileUpsertWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface FileScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: FileScalarWhereInput[] | FileScalarWhereInput;
  OR?: FileScalarWhereInput[] | FileScalarWhereInput;
  NOT?: FileScalarWhereInput[] | FileScalarWhereInput;
}

export interface FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput;
  data: FileUpdateManyDataInput;
}

export interface FileUpdateManyDataInput {
  size?: Int;
  type?: String;
  name?: String;
  url?: String;
}

export interface CandidateUpdatecoverLettersStringInput {
  set?: String[] | String;
}

export interface TagUpdateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  update?:
    | TagUpdateWithWhereUniqueNestedInput[]
    | TagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TagUpsertWithWhereUniqueNestedInput[]
    | TagUpsertWithWhereUniqueNestedInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface TagUpdateDataInput {
  label?: String;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  label?: String;
}

export interface CandidateUpdatesourceInput {
  set?: String[] | String;
}

export interface FieldLinkUpdateManyInput {
  create?: FieldLinkCreateInput[] | FieldLinkCreateInput;
  update?:
    | FieldLinkUpdateWithWhereUniqueNestedInput[]
    | FieldLinkUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FieldLinkUpsertWithWhereUniqueNestedInput[]
    | FieldLinkUpsertWithWhereUniqueNestedInput;
  delete?: FieldLinkWhereUniqueInput[] | FieldLinkWhereUniqueInput;
  connect?: FieldLinkWhereUniqueInput[] | FieldLinkWhereUniqueInput;
  disconnect?: FieldLinkWhereUniqueInput[] | FieldLinkWhereUniqueInput;
  deleteMany?: FieldLinkScalarWhereInput[] | FieldLinkScalarWhereInput;
  updateMany?:
    | FieldLinkUpdateManyWithWhereNestedInput[]
    | FieldLinkUpdateManyWithWhereNestedInput;
}

export interface FieldLinkUpdateWithWhereUniqueNestedInput {
  where: FieldLinkWhereUniqueInput;
  data: FieldLinkUpdateDataInput;
}

export interface FieldLinkUpdateDataInput {
  field?: FieldUpdateOneRequiredInput;
  value?: String;
}

export interface FieldUpdateOneRequiredInput {
  create?: FieldCreateInput;
  update?: FieldUpdateDataInput;
  upsert?: FieldUpsertNestedInput;
  connect?: FieldWhereUniqueInput;
}

export interface FieldUpdateDataInput {
  type?: FieldType;
  label?: String;
}

export interface FieldUpsertNestedInput {
  update: FieldUpdateDataInput;
  create: FieldCreateInput;
}

export interface FieldLinkUpsertWithWhereUniqueNestedInput {
  where: FieldLinkWhereUniqueInput;
  update: FieldLinkUpdateDataInput;
  create: FieldLinkCreateInput;
}

export interface FieldLinkScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: FieldLinkScalarWhereInput[] | FieldLinkScalarWhereInput;
  OR?: FieldLinkScalarWhereInput[] | FieldLinkScalarWhereInput;
  NOT?: FieldLinkScalarWhereInput[] | FieldLinkScalarWhereInput;
}

export interface FieldLinkUpdateManyWithWhereNestedInput {
  where: FieldLinkScalarWhereInput;
  data: FieldLinkUpdateManyDataInput;
}

export interface FieldLinkUpdateManyDataInput {
  value?: String;
}

export interface TaskUpdateManyWithoutCandidateInput {
  create?: TaskCreateWithoutCandidateInput[] | TaskCreateWithoutCandidateInput;
  delete?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  disconnect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  update?:
    | TaskUpdateWithWhereUniqueWithoutCandidateInput[]
    | TaskUpdateWithWhereUniqueWithoutCandidateInput;
  upsert?:
    | TaskUpsertWithWhereUniqueWithoutCandidateInput[]
    | TaskUpsertWithWhereUniqueWithoutCandidateInput;
  deleteMany?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  updateMany?:
    | TaskUpdateManyWithWhereNestedInput[]
    | TaskUpdateManyWithWhereNestedInput;
}

export interface TaskUpdateWithWhereUniqueWithoutCandidateInput {
  where: TaskWhereUniqueInput;
  data: TaskUpdateWithoutCandidateDataInput;
}

export interface TaskUpdateWithoutCandidateDataInput {
  subscribers?: UserUpdateManyWithoutSubscriptionTasksInput;
  owners?: UserUpdateManyWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserUpdateManyWithoutSubscriptionTasksInput {
  create?:
    | UserCreateWithoutSubscriptionTasksInput[]
    | UserCreateWithoutSubscriptionTasksInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSubscriptionTasksInput[]
    | UserUpdateWithWhereUniqueWithoutSubscriptionTasksInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSubscriptionTasksInput[]
    | UserUpsertWithWhereUniqueWithoutSubscriptionTasksInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutSubscriptionTasksInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSubscriptionTasksDataInput;
}

export interface UserUpdateWithoutSubscriptionTasksDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput;
  events?: EventUpdateOneWithoutActorUserInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  subscriptionJobs?: JobUpdateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateUpdateManyWithoutSubscribersInput;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface TaskUpdateManyWithoutOwnersInput {
  create?: TaskCreateWithoutOwnersInput[] | TaskCreateWithoutOwnersInput;
  delete?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  disconnect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  update?:
    | TaskUpdateWithWhereUniqueWithoutOwnersInput[]
    | TaskUpdateWithWhereUniqueWithoutOwnersInput;
  upsert?:
    | TaskUpsertWithWhereUniqueWithoutOwnersInput[]
    | TaskUpsertWithWhereUniqueWithoutOwnersInput;
  deleteMany?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  updateMany?:
    | TaskUpdateManyWithWhereNestedInput[]
    | TaskUpdateManyWithWhereNestedInput;
}

export interface TaskUpdateWithWhereUniqueWithoutOwnersInput {
  where: TaskWhereUniqueInput;
  data: TaskUpdateWithoutOwnersDataInput;
}

export interface TaskUpdateWithoutOwnersDataInput {
  subscribers?: UserUpdateManyWithoutSubscriptionTasksInput;
  candidate?: CandidateUpdateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface CandidateUpdateOneWithoutTasksInput {
  create?: CandidateCreateWithoutTasksInput;
  update?: CandidateUpdateWithoutTasksDataInput;
  upsert?: CandidateUpsertWithoutTasksInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateUpdateWithoutTasksDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput;
  events?: EventUpdateManyWithoutTargetCandidateInput;
  subscribers?: UserUpdateManyWithoutSubscriptionCandidatesInput;
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  source?: CandidateUpdatesourceInput;
  fields?: FieldLinkUpdateManyInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface ApplicationUpdateManyWithoutCandidateInput {
  create?:
    | ApplicationCreateWithoutCandidateInput[]
    | ApplicationCreateWithoutCandidateInput;
  delete?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  connect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  disconnect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  update?:
    | ApplicationUpdateWithWhereUniqueWithoutCandidateInput[]
    | ApplicationUpdateWithWhereUniqueWithoutCandidateInput;
  upsert?:
    | ApplicationUpsertWithWhereUniqueWithoutCandidateInput[]
    | ApplicationUpsertWithWhereUniqueWithoutCandidateInput;
  deleteMany?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
  updateMany?:
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput;
}

export interface ApplicationUpdateWithWhereUniqueWithoutCandidateInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutCandidateDataInput;
}

export interface ApplicationUpdateWithoutCandidateDataInput {
  type?: ApplicationType;
  disqualificationLink?: DisqualificationLinkUpdateOneInput;
  stage?: StageUpdateOneRequiredInput;
  job?: JobUpdateOneRequiredWithoutApplicationsInput;
}

export interface StageUpdateOneRequiredInput {
  create?: StageCreateInput;
  update?: StageUpdateDataInput;
  upsert?: StageUpsertNestedInput;
  connect?: StageWhereUniqueInput;
}

export interface StageUpdateDataInput {
  name?: String;
  description?: String;
  type?: StageType;
}

export interface StageUpsertNestedInput {
  update: StageUpdateDataInput;
  create: StageCreateInput;
}

export interface JobUpdateOneRequiredWithoutApplicationsInput {
  create?: JobCreateWithoutApplicationsInput;
  update?: JobUpdateWithoutApplicationsDataInput;
  upsert?: JobUpsertWithoutApplicationsInput;
  connect?: JobWhereUniqueInput;
}

export interface JobUpdateWithoutApplicationsDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutJobsInput;
  subscribers?: UserUpdateManyWithoutSubscriptionJobsInput;
  events?: EventUpdateManyWithoutTargetJobInput;
  workflow?: WorkflowUpdateOneRequiredInput;
  comments?: CommentUpdateManyInput;
  type?: JobType;
  department?: String;
  locations?: LocationUpdateManyInput;
  name?: String;
  description?: String;
  requirements?: String;
}

export interface EventUpdateManyWithoutTargetJobInput {
  create?:
    | EventCreateWithoutTargetJobInput[]
    | EventCreateWithoutTargetJobInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutTargetJobInput[]
    | EventUpdateWithWhereUniqueWithoutTargetJobInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutTargetJobInput[]
    | EventUpsertWithWhereUniqueWithoutTargetJobInput;
  deleteMany?: EventScalarWhereInput[] | EventScalarWhereInput;
  updateMany?:
    | EventUpdateManyWithWhereNestedInput[]
    | EventUpdateManyWithWhereNestedInput;
}

export interface EventUpdateWithWhereUniqueWithoutTargetJobInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutTargetJobDataInput;
}

export interface EventUpdateWithoutTargetJobDataInput {
  type?: EventType;
  actorType?: EventActorType;
  actorUser?: UserUpdateOneWithoutEventsInput;
  actorCandidate?: CandidateUpdateOneInput;
  targetType?: EventTargetType;
  targetCandidate?: CandidateUpdateOneWithoutEventsInput;
  targetTask?: TaskUpdateOneInput;
  targetWorkspace?: WorkspaceUpdateOneWithoutEventsInput;
}

export interface TaskUpdateOneInput {
  create?: TaskCreateInput;
  update?: TaskUpdateDataInput;
  upsert?: TaskUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TaskWhereUniqueInput;
}

export interface TaskUpdateDataInput {
  subscribers?: UserUpdateManyWithoutSubscriptionTasksInput;
  owners?: UserUpdateManyWithoutTasksInput;
  candidate?: CandidateUpdateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserUpdateManyWithoutTasksInput {
  create?: UserCreateWithoutTasksInput[] | UserCreateWithoutTasksInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTasksInput[]
    | UserUpdateWithWhereUniqueWithoutTasksInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTasksInput[]
    | UserUpsertWithWhereUniqueWithoutTasksInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutTasksInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTasksDataInput;
}

export interface UserUpdateWithoutTasksDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput;
  events?: EventUpdateOneWithoutActorUserInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  subscriptionJobs?: JobUpdateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateUpdateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskUpdateManyWithoutSubscribersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface TaskUpdateManyWithoutSubscribersInput {
  create?:
    | TaskCreateWithoutSubscribersInput[]
    | TaskCreateWithoutSubscribersInput;
  delete?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  disconnect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  update?:
    | TaskUpdateWithWhereUniqueWithoutSubscribersInput[]
    | TaskUpdateWithWhereUniqueWithoutSubscribersInput;
  upsert?:
    | TaskUpsertWithWhereUniqueWithoutSubscribersInput[]
    | TaskUpsertWithWhereUniqueWithoutSubscribersInput;
  deleteMany?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  updateMany?:
    | TaskUpdateManyWithWhereNestedInput[]
    | TaskUpdateManyWithWhereNestedInput;
}

export interface TaskUpdateWithWhereUniqueWithoutSubscribersInput {
  where: TaskWhereUniqueInput;
  data: TaskUpdateWithoutSubscribersDataInput;
}

export interface TaskUpdateWithoutSubscribersDataInput {
  owners?: UserUpdateManyWithoutTasksInput;
  candidate?: CandidateUpdateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface TaskUpsertWithWhereUniqueWithoutSubscribersInput {
  where: TaskWhereUniqueInput;
  update: TaskUpdateWithoutSubscribersDataInput;
  create: TaskCreateWithoutSubscribersInput;
}

export interface TaskScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  dueAt?: DateTimeInput;
  dueAt_not?: DateTimeInput;
  dueAt_in?: DateTimeInput[] | DateTimeInput;
  dueAt_not_in?: DateTimeInput[] | DateTimeInput;
  dueAt_lt?: DateTimeInput;
  dueAt_lte?: DateTimeInput;
  dueAt_gt?: DateTimeInput;
  dueAt_gte?: DateTimeInput;
  AND?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  OR?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  NOT?: TaskScalarWhereInput[] | TaskScalarWhereInput;
}

export interface TaskUpdateManyWithWhereNestedInput {
  where: TaskScalarWhereInput;
  data: TaskUpdateManyDataInput;
}

export interface TaskUpdateManyDataInput {
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserUpsertWithWhereUniqueWithoutTasksInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTasksDataInput;
  create: UserCreateWithoutTasksInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  lastLogin?: DateTimeInput;
  lastLogin_not?: DateTimeInput;
  lastLogin_in?: DateTimeInput[] | DateTimeInput;
  lastLogin_not_in?: DateTimeInput[] | DateTimeInput;
  lastLogin_lt?: DateTimeInput;
  lastLogin_lte?: DateTimeInput;
  lastLogin_gt?: DateTimeInput;
  lastLogin_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
}

export interface TaskUpsertNestedInput {
  update: TaskUpdateDataInput;
  create: TaskCreateInput;
}

export interface WorkspaceUpdateOneWithoutEventsInput {
  create?: WorkspaceCreateWithoutEventsInput;
  update?: WorkspaceUpdateWithoutEventsDataInput;
  upsert?: WorkspaceUpsertWithoutEventsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceUpdateWithoutEventsDataInput {
  users?: UserUpdateManyWithoutWorkspaceInput;
  jobs?: JobUpdateManyWithoutWorkspaceInput;
  candidates?: CandidateUpdateManyWithoutWorkspaceInput;
  workflows?: WorkflowUpdateManyInput;
  workflowDefault?: WorkflowUpdateOneInput;
  invites?: InviteUpdateManyInput;
  tags?: TagUpdateManyInput;
  name?: String;
}

export interface JobUpdateManyWithoutWorkspaceInput {
  create?: JobCreateWithoutWorkspaceInput[] | JobCreateWithoutWorkspaceInput;
  delete?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  disconnect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  update?:
    | JobUpdateWithWhereUniqueWithoutWorkspaceInput[]
    | JobUpdateWithWhereUniqueWithoutWorkspaceInput;
  upsert?:
    | JobUpsertWithWhereUniqueWithoutWorkspaceInput[]
    | JobUpsertWithWhereUniqueWithoutWorkspaceInput;
  deleteMany?: JobScalarWhereInput[] | JobScalarWhereInput;
  updateMany?:
    | JobUpdateManyWithWhereNestedInput[]
    | JobUpdateManyWithWhereNestedInput;
}

export interface JobUpdateWithWhereUniqueWithoutWorkspaceInput {
  where: JobWhereUniqueInput;
  data: JobUpdateWithoutWorkspaceDataInput;
}

export interface JobUpdateWithoutWorkspaceDataInput {
  subscribers?: UserUpdateManyWithoutSubscriptionJobsInput;
  events?: EventUpdateManyWithoutTargetJobInput;
  applications?: ApplicationUpdateManyWithoutJobInput;
  workflow?: WorkflowUpdateOneRequiredInput;
  comments?: CommentUpdateManyInput;
  type?: JobType;
  department?: String;
  locations?: LocationUpdateManyInput;
  name?: String;
  description?: String;
  requirements?: String;
}

export interface ApplicationUpdateManyWithoutJobInput {
  create?:
    | ApplicationCreateWithoutJobInput[]
    | ApplicationCreateWithoutJobInput;
  delete?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  connect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  disconnect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  update?:
    | ApplicationUpdateWithWhereUniqueWithoutJobInput[]
    | ApplicationUpdateWithWhereUniqueWithoutJobInput;
  upsert?:
    | ApplicationUpsertWithWhereUniqueWithoutJobInput[]
    | ApplicationUpsertWithWhereUniqueWithoutJobInput;
  deleteMany?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
  updateMany?:
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput;
}

export interface ApplicationUpdateWithWhereUniqueWithoutJobInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutJobDataInput;
}

export interface ApplicationUpdateWithoutJobDataInput {
  type?: ApplicationType;
  disqualificationLink?: DisqualificationLinkUpdateOneInput;
  stage?: StageUpdateOneRequiredInput;
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput;
}

export interface CandidateUpdateOneRequiredWithoutApplicationsInput {
  create?: CandidateCreateWithoutApplicationsInput;
  update?: CandidateUpdateWithoutApplicationsDataInput;
  upsert?: CandidateUpsertWithoutApplicationsInput;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateUpdateWithoutApplicationsDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput;
  events?: EventUpdateManyWithoutTargetCandidateInput;
  subscribers?: UserUpdateManyWithoutSubscriptionCandidatesInput;
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  source?: CandidateUpdatesourceInput;
  fields?: FieldLinkUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface CommentUpdateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  update?:
    | CommentUpdateWithWhereUniqueNestedInput[]
    | CommentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CommentUpsertWithWhereUniqueNestedInput[]
    | CommentUpsertWithWhereUniqueNestedInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateDataInput;
}

export interface CommentUpdateDataInput {
  createdBy?: UserUpdateOneRequiredInput;
  parent?: CommentUpdateOneInput;
  content?: String;
}

export interface CommentUpdateOneInput {
  create?: CommentCreateInput;
  update?: CommentUpdateDataInput;
  upsert?: CommentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CommentWhereUniqueInput;
}

export interface CommentUpsertNestedInput {
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface CommentUpsertWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  content?: String;
}

export interface CandidateUpsertWithoutApplicationsInput {
  update: CandidateUpdateWithoutApplicationsDataInput;
  create: CandidateCreateWithoutApplicationsInput;
}

export interface ApplicationUpsertWithWhereUniqueWithoutJobInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutJobDataInput;
  create: ApplicationCreateWithoutJobInput;
}

export interface ApplicationScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: ApplicationType;
  type_not?: ApplicationType;
  type_in?: ApplicationType[] | ApplicationType;
  type_not_in?: ApplicationType[] | ApplicationType;
  AND?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
  OR?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
  NOT?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
}

export interface ApplicationUpdateManyWithWhereNestedInput {
  where: ApplicationScalarWhereInput;
  data: ApplicationUpdateManyDataInput;
}

export interface ApplicationUpdateManyDataInput {
  type?: ApplicationType;
}

export interface WorkflowUpdateOneRequiredInput {
  create?: WorkflowCreateInput;
  update?: WorkflowUpdateDataInput;
  upsert?: WorkflowUpsertNestedInput;
  connect?: WorkflowWhereUniqueInput;
}

export interface WorkflowUpdateDataInput {
  name?: String;
  description?: String;
  stages?: StageUpdateManyInput;
  disqualifications?: DisqualificationUpdateManyInput;
  fields?: FieldUpdateManyInput;
}

export interface StageUpdateManyInput {
  create?: StageCreateInput[] | StageCreateInput;
  update?:
    | StageUpdateWithWhereUniqueNestedInput[]
    | StageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StageUpsertWithWhereUniqueNestedInput[]
    | StageUpsertWithWhereUniqueNestedInput;
  delete?: StageWhereUniqueInput[] | StageWhereUniqueInput;
  connect?: StageWhereUniqueInput[] | StageWhereUniqueInput;
  disconnect?: StageWhereUniqueInput[] | StageWhereUniqueInput;
  deleteMany?: StageScalarWhereInput[] | StageScalarWhereInput;
  updateMany?:
    | StageUpdateManyWithWhereNestedInput[]
    | StageUpdateManyWithWhereNestedInput;
}

export interface StageUpdateWithWhereUniqueNestedInput {
  where: StageWhereUniqueInput;
  data: StageUpdateDataInput;
}

export interface StageUpsertWithWhereUniqueNestedInput {
  where: StageWhereUniqueInput;
  update: StageUpdateDataInput;
  create: StageCreateInput;
}

export interface StageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  type?: StageType;
  type_not?: StageType;
  type_in?: StageType[] | StageType;
  type_not_in?: StageType[] | StageType;
  AND?: StageScalarWhereInput[] | StageScalarWhereInput;
  OR?: StageScalarWhereInput[] | StageScalarWhereInput;
  NOT?: StageScalarWhereInput[] | StageScalarWhereInput;
}

export interface StageUpdateManyWithWhereNestedInput {
  where: StageScalarWhereInput;
  data: StageUpdateManyDataInput;
}

export interface StageUpdateManyDataInput {
  name?: String;
  description?: String;
  type?: StageType;
}

export interface DisqualificationUpdateManyInput {
  create?: DisqualificationCreateInput[] | DisqualificationCreateInput;
  update?:
    | DisqualificationUpdateWithWhereUniqueNestedInput[]
    | DisqualificationUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DisqualificationUpsertWithWhereUniqueNestedInput[]
    | DisqualificationUpsertWithWhereUniqueNestedInput;
  delete?:
    | DisqualificationWhereUniqueInput[]
    | DisqualificationWhereUniqueInput;
  connect?:
    | DisqualificationWhereUniqueInput[]
    | DisqualificationWhereUniqueInput;
  disconnect?:
    | DisqualificationWhereUniqueInput[]
    | DisqualificationWhereUniqueInput;
  deleteMany?:
    | DisqualificationScalarWhereInput[]
    | DisqualificationScalarWhereInput;
  updateMany?:
    | DisqualificationUpdateManyWithWhereNestedInput[]
    | DisqualificationUpdateManyWithWhereNestedInput;
}

export interface DisqualificationUpdateWithWhereUniqueNestedInput {
  where: DisqualificationWhereUniqueInput;
  data: DisqualificationUpdateDataInput;
}

export interface DisqualificationUpsertWithWhereUniqueNestedInput {
  where: DisqualificationWhereUniqueInput;
  update: DisqualificationUpdateDataInput;
  create: DisqualificationCreateInput;
}

export interface DisqualificationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: DisqualificationScalarWhereInput[] | DisqualificationScalarWhereInput;
  OR?: DisqualificationScalarWhereInput[] | DisqualificationScalarWhereInput;
  NOT?: DisqualificationScalarWhereInput[] | DisqualificationScalarWhereInput;
}

export interface DisqualificationUpdateManyWithWhereNestedInput {
  where: DisqualificationScalarWhereInput;
  data: DisqualificationUpdateManyDataInput;
}

export interface DisqualificationUpdateManyDataInput {
  name?: String;
  description?: String;
}

export interface FieldUpdateManyInput {
  create?: FieldCreateInput[] | FieldCreateInput;
  update?:
    | FieldUpdateWithWhereUniqueNestedInput[]
    | FieldUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FieldUpsertWithWhereUniqueNestedInput[]
    | FieldUpsertWithWhereUniqueNestedInput;
  delete?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
  connect?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
  disconnect?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
  deleteMany?: FieldScalarWhereInput[] | FieldScalarWhereInput;
  updateMany?:
    | FieldUpdateManyWithWhereNestedInput[]
    | FieldUpdateManyWithWhereNestedInput;
}

export interface FieldUpdateWithWhereUniqueNestedInput {
  where: FieldWhereUniqueInput;
  data: FieldUpdateDataInput;
}

export interface FieldUpsertWithWhereUniqueNestedInput {
  where: FieldWhereUniqueInput;
  update: FieldUpdateDataInput;
  create: FieldCreateInput;
}

export interface FieldScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: FieldType;
  type_not?: FieldType;
  type_in?: FieldType[] | FieldType;
  type_not_in?: FieldType[] | FieldType;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  AND?: FieldScalarWhereInput[] | FieldScalarWhereInput;
  OR?: FieldScalarWhereInput[] | FieldScalarWhereInput;
  NOT?: FieldScalarWhereInput[] | FieldScalarWhereInput;
}

export interface FieldUpdateManyWithWhereNestedInput {
  where: FieldScalarWhereInput;
  data: FieldUpdateManyDataInput;
}

export interface FieldUpdateManyDataInput {
  type?: FieldType;
  label?: String;
}

export interface WorkflowUpsertNestedInput {
  update: WorkflowUpdateDataInput;
  create: WorkflowCreateInput;
}

export interface LocationUpdateManyInput {
  create?: LocationCreateInput[] | LocationCreateInput;
  update?:
    | LocationUpdateWithWhereUniqueNestedInput[]
    | LocationUpdateWithWhereUniqueNestedInput;
  upsert?:
    | LocationUpsertWithWhereUniqueNestedInput[]
    | LocationUpsertWithWhereUniqueNestedInput;
  delete?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  disconnect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  deleteMany?: LocationScalarWhereInput[] | LocationScalarWhereInput;
  updateMany?:
    | LocationUpdateManyWithWhereNestedInput[]
    | LocationUpdateManyWithWhereNestedInput;
}

export interface LocationUpdateWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput;
  data: LocationUpdateDataInput;
}

export interface LocationUpdateDataInput {
  country?: String;
  region?: String;
  city?: String;
  zip?: String;
}

export interface LocationUpsertWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput;
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface LocationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  region?: String;
  region_not?: String;
  region_in?: String[] | String;
  region_not_in?: String[] | String;
  region_lt?: String;
  region_lte?: String;
  region_gt?: String;
  region_gte?: String;
  region_contains?: String;
  region_not_contains?: String;
  region_starts_with?: String;
  region_not_starts_with?: String;
  region_ends_with?: String;
  region_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  zip?: String;
  zip_not?: String;
  zip_in?: String[] | String;
  zip_not_in?: String[] | String;
  zip_lt?: String;
  zip_lte?: String;
  zip_gt?: String;
  zip_gte?: String;
  zip_contains?: String;
  zip_not_contains?: String;
  zip_starts_with?: String;
  zip_not_starts_with?: String;
  zip_ends_with?: String;
  zip_not_ends_with?: String;
  AND?: LocationScalarWhereInput[] | LocationScalarWhereInput;
  OR?: LocationScalarWhereInput[] | LocationScalarWhereInput;
  NOT?: LocationScalarWhereInput[] | LocationScalarWhereInput;
}

export interface LocationUpdateManyWithWhereNestedInput {
  where: LocationScalarWhereInput;
  data: LocationUpdateManyDataInput;
}

export interface LocationUpdateManyDataInput {
  country?: String;
  region?: String;
  city?: String;
  zip?: String;
}

export interface JobUpsertWithWhereUniqueWithoutWorkspaceInput {
  where: JobWhereUniqueInput;
  update: JobUpdateWithoutWorkspaceDataInput;
  create: JobCreateWithoutWorkspaceInput;
}

export interface JobScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: JobType;
  type_not?: JobType;
  type_in?: JobType[] | JobType;
  type_not_in?: JobType[] | JobType;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  requirements?: String;
  requirements_not?: String;
  requirements_in?: String[] | String;
  requirements_not_in?: String[] | String;
  requirements_lt?: String;
  requirements_lte?: String;
  requirements_gt?: String;
  requirements_gte?: String;
  requirements_contains?: String;
  requirements_not_contains?: String;
  requirements_starts_with?: String;
  requirements_not_starts_with?: String;
  requirements_ends_with?: String;
  requirements_not_ends_with?: String;
  AND?: JobScalarWhereInput[] | JobScalarWhereInput;
  OR?: JobScalarWhereInput[] | JobScalarWhereInput;
  NOT?: JobScalarWhereInput[] | JobScalarWhereInput;
}

export interface JobUpdateManyWithWhereNestedInput {
  where: JobScalarWhereInput;
  data: JobUpdateManyDataInput;
}

export interface JobUpdateManyDataInput {
  type?: JobType;
  department?: String;
  name?: String;
  description?: String;
  requirements?: String;
}

export interface WorkflowUpdateManyInput {
  create?: WorkflowCreateInput[] | WorkflowCreateInput;
  update?:
    | WorkflowUpdateWithWhereUniqueNestedInput[]
    | WorkflowUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WorkflowUpsertWithWhereUniqueNestedInput[]
    | WorkflowUpsertWithWhereUniqueNestedInput;
  delete?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
  connect?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
  disconnect?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
  deleteMany?: WorkflowScalarWhereInput[] | WorkflowScalarWhereInput;
  updateMany?:
    | WorkflowUpdateManyWithWhereNestedInput[]
    | WorkflowUpdateManyWithWhereNestedInput;
}

export interface WorkflowUpdateWithWhereUniqueNestedInput {
  where: WorkflowWhereUniqueInput;
  data: WorkflowUpdateDataInput;
}

export interface WorkflowUpsertWithWhereUniqueNestedInput {
  where: WorkflowWhereUniqueInput;
  update: WorkflowUpdateDataInput;
  create: WorkflowCreateInput;
}

export interface WorkflowScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: WorkflowScalarWhereInput[] | WorkflowScalarWhereInput;
  OR?: WorkflowScalarWhereInput[] | WorkflowScalarWhereInput;
  NOT?: WorkflowScalarWhereInput[] | WorkflowScalarWhereInput;
}

export interface WorkflowUpdateManyWithWhereNestedInput {
  where: WorkflowScalarWhereInput;
  data: WorkflowUpdateManyDataInput;
}

export interface WorkflowUpdateManyDataInput {
  name?: String;
  description?: String;
}

export interface WorkflowUpdateOneInput {
  create?: WorkflowCreateInput;
  update?: WorkflowUpdateDataInput;
  upsert?: WorkflowUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WorkflowWhereUniqueInput;
}

export interface InviteUpdateManyInput {
  create?: InviteCreateInput[] | InviteCreateInput;
  update?:
    | InviteUpdateWithWhereUniqueNestedInput[]
    | InviteUpdateWithWhereUniqueNestedInput;
  upsert?:
    | InviteUpsertWithWhereUniqueNestedInput[]
    | InviteUpsertWithWhereUniqueNestedInput;
  delete?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  connect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  disconnect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  deleteMany?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  updateMany?:
    | InviteUpdateManyWithWhereNestedInput[]
    | InviteUpdateManyWithWhereNestedInput;
}

export interface InviteUpdateWithWhereUniqueNestedInput {
  where: InviteWhereUniqueInput;
  data: InviteUpdateDataInput;
}

export interface InviteUpdateDataInput {
  email?: String;
  expireAt?: DateTimeInput;
  invitedBy?: UserUpdateOneRequiredInput;
}

export interface InviteUpsertWithWhereUniqueNestedInput {
  where: InviteWhereUniqueInput;
  update: InviteUpdateDataInput;
  create: InviteCreateInput;
}

export interface InviteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  expireAt?: DateTimeInput;
  expireAt_not?: DateTimeInput;
  expireAt_in?: DateTimeInput[] | DateTimeInput;
  expireAt_not_in?: DateTimeInput[] | DateTimeInput;
  expireAt_lt?: DateTimeInput;
  expireAt_lte?: DateTimeInput;
  expireAt_gt?: DateTimeInput;
  expireAt_gte?: DateTimeInput;
  AND?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  OR?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  NOT?: InviteScalarWhereInput[] | InviteScalarWhereInput;
}

export interface InviteUpdateManyWithWhereNestedInput {
  where: InviteScalarWhereInput;
  data: InviteUpdateManyDataInput;
}

export interface InviteUpdateManyDataInput {
  email?: String;
  expireAt?: DateTimeInput;
}

export interface WorkspaceUpsertWithoutEventsInput {
  update: WorkspaceUpdateWithoutEventsDataInput;
  create: WorkspaceCreateWithoutEventsInput;
}

export interface EventUpsertWithWhereUniqueWithoutTargetJobInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutTargetJobDataInput;
  create: EventCreateWithoutTargetJobInput;
}

export interface EventScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: EventType;
  type_not?: EventType;
  type_in?: EventType[] | EventType;
  type_not_in?: EventType[] | EventType;
  actorType?: EventActorType;
  actorType_not?: EventActorType;
  actorType_in?: EventActorType[] | EventActorType;
  actorType_not_in?: EventActorType[] | EventActorType;
  targetType?: EventTargetType;
  targetType_not?: EventTargetType;
  targetType_in?: EventTargetType[] | EventTargetType;
  targetType_not_in?: EventTargetType[] | EventTargetType;
  AND?: EventScalarWhereInput[] | EventScalarWhereInput;
  OR?: EventScalarWhereInput[] | EventScalarWhereInput;
  NOT?: EventScalarWhereInput[] | EventScalarWhereInput;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface EventUpdateManyDataInput {
  type?: EventType;
  actorType?: EventActorType;
  targetType?: EventTargetType;
}

export interface JobUpsertWithoutApplicationsInput {
  update: JobUpdateWithoutApplicationsDataInput;
  create: JobCreateWithoutApplicationsInput;
}

export interface ApplicationUpsertWithWhereUniqueWithoutCandidateInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutCandidateDataInput;
  create: ApplicationCreateWithoutCandidateInput;
}

export interface CandidateUpsertWithoutTasksInput {
  update: CandidateUpdateWithoutTasksDataInput;
  create: CandidateCreateWithoutTasksInput;
}

export interface TaskUpsertWithWhereUniqueWithoutOwnersInput {
  where: TaskWhereUniqueInput;
  update: TaskUpdateWithoutOwnersDataInput;
  create: TaskCreateWithoutOwnersInput;
}

export interface UserUpsertWithWhereUniqueWithoutSubscriptionTasksInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSubscriptionTasksDataInput;
  create: UserCreateWithoutSubscriptionTasksInput;
}

export interface TaskUpsertWithWhereUniqueWithoutCandidateInput {
  where: TaskWhereUniqueInput;
  update: TaskUpdateWithoutCandidateDataInput;
  create: TaskCreateWithoutCandidateInput;
}

export interface CandidateUpsertWithWhereUniqueWithoutSubscribersInput {
  where: CandidateWhereUniqueInput;
  update: CandidateUpdateWithoutSubscribersDataInput;
  create: CandidateCreateWithoutSubscribersInput;
}

export interface CandidateScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  metaCompany?: String;
  metaCompany_not?: String;
  metaCompany_in?: String[] | String;
  metaCompany_not_in?: String[] | String;
  metaCompany_lt?: String;
  metaCompany_lte?: String;
  metaCompany_gt?: String;
  metaCompany_gte?: String;
  metaCompany_contains?: String;
  metaCompany_not_contains?: String;
  metaCompany_starts_with?: String;
  metaCompany_not_starts_with?: String;
  metaCompany_ends_with?: String;
  metaCompany_not_ends_with?: String;
  metaHeadline?: String;
  metaHeadline_not?: String;
  metaHeadline_in?: String[] | String;
  metaHeadline_not_in?: String[] | String;
  metaHeadline_lt?: String;
  metaHeadline_lte?: String;
  metaHeadline_gt?: String;
  metaHeadline_gte?: String;
  metaHeadline_contains?: String;
  metaHeadline_not_contains?: String;
  metaHeadline_starts_with?: String;
  metaHeadline_not_starts_with?: String;
  metaHeadline_ends_with?: String;
  metaHeadline_not_ends_with?: String;
  metaPosition?: String;
  metaPosition_not?: String;
  metaPosition_in?: String[] | String;
  metaPosition_not_in?: String[] | String;
  metaPosition_lt?: String;
  metaPosition_lte?: String;
  metaPosition_gt?: String;
  metaPosition_gte?: String;
  metaPosition_contains?: String;
  metaPosition_not_contains?: String;
  metaPosition_starts_with?: String;
  metaPosition_not_starts_with?: String;
  metaPosition_ends_with?: String;
  metaPosition_not_ends_with?: String;
  AND?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
  OR?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
  NOT?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
}

export interface CandidateUpdateManyWithWhereNestedInput {
  where: CandidateScalarWhereInput;
  data: CandidateUpdateManyDataInput;
}

export interface CandidateUpdateManyDataInput {
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  source?: CandidateUpdatesourceInput;
}

export interface UserUpsertWithWhereUniqueWithoutSubscriptionJobsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSubscriptionJobsDataInput;
  create: UserCreateWithoutSubscriptionJobsInput;
}

export interface JobUpsertWithoutEventsInput {
  update: JobUpdateWithoutEventsDataInput;
  create: JobCreateWithoutEventsInput;
}

export interface EventUpsertWithWhereUniqueWithoutTargetCandidateInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutTargetCandidateDataInput;
  create: EventCreateWithoutTargetCandidateInput;
}

export interface CandidateUpsertWithWhereUniqueWithoutWorkspaceInput {
  where: CandidateWhereUniqueInput;
  update: CandidateUpdateWithoutWorkspaceDataInput;
  create: CandidateCreateWithoutWorkspaceInput;
}

export interface WorkspaceUpsertWithoutJobsInput {
  update: WorkspaceUpdateWithoutJobsDataInput;
  create: WorkspaceCreateWithoutJobsInput;
}

export interface JobUpsertWithWhereUniqueWithoutSubscribersInput {
  where: JobWhereUniqueInput;
  update: JobUpdateWithoutSubscribersDataInput;
  create: JobCreateWithoutSubscribersInput;
}

export interface UserUpsertWithWhereUniqueWithoutSubscriptionCandidatesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSubscriptionCandidatesDataInput;
  create: UserCreateWithoutSubscriptionCandidatesInput;
}

export interface CandidateUpsertWithoutEventsInput {
  update: CandidateUpdateWithoutEventsDataInput;
  create: CandidateCreateWithoutEventsInput;
}

export interface EventUpsertWithoutActorUserInput {
  update: EventUpdateWithoutActorUserDataInput;
  create: EventCreateWithoutActorUserInput;
}

export interface UserUpsertWithWhereUniqueWithoutWorkspaceInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutWorkspaceDataInput;
  create: UserCreateWithoutWorkspaceInput;
}

export interface WorkspaceUpsertWithoutCandidatesInput {
  update: WorkspaceUpdateWithoutCandidatesDataInput;
  create: WorkspaceCreateWithoutCandidatesInput;
}

export interface CandidateUpsertNestedInput {
  update: CandidateUpdateDataInput;
  create: CandidateCreateInput;
}

export interface EventUpsertNestedInput {
  update: EventUpdateDataInput;
  create: EventCreateInput;
}

export interface NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateWithoutUserDataInput;
  create: NotificationCreateWithoutUserInput;
}

export interface NotificationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: NotificationType;
  type_not?: NotificationType;
  type_in?: NotificationType[] | NotificationType;
  type_not_in?: NotificationType[] | NotificationType;
  AND?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  OR?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
  NOT?: NotificationScalarWhereInput[] | NotificationScalarWhereInput;
}

export interface NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput;
  data: NotificationUpdateManyDataInput;
}

export interface NotificationUpdateManyDataInput {
  type?: NotificationType;
}

export interface UserUpsertWithoutEventsInput {
  update: UserUpdateWithoutEventsDataInput;
  create: UserCreateWithoutEventsInput;
}

export interface EventUpsertWithWhereUniqueWithoutTargetWorkspaceInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutTargetWorkspaceDataInput;
  create: EventCreateWithoutTargetWorkspaceInput;
}

export interface WorkspaceUpsertWithoutUsersInput {
  update: WorkspaceUpdateWithoutUsersDataInput;
  create: WorkspaceCreateWithoutUsersInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface DisqualificationLinkUpsertNestedInput {
  update: DisqualificationLinkUpdateDataInput;
  create: DisqualificationLinkCreateInput;
}

export interface ApplicationUpdateManyMutationInput {
  type?: ApplicationType;
}

export interface CandidateUpdateInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutCandidatesInput;
  events?: EventUpdateManyWithoutTargetCandidateInput;
  subscribers?: UserUpdateManyWithoutSubscriptionCandidatesInput;
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  source?: CandidateUpdatesourceInput;
  fields?: FieldLinkUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface CandidateUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  source?: CandidateUpdatesourceInput;
}

export interface CommentUpdateInput {
  createdBy?: UserUpdateOneRequiredInput;
  parent?: CommentUpdateOneInput;
  content?: String;
}

export interface CommentUpdateManyMutationInput {
  content?: String;
}

export interface DisqualificationUpdateInput {
  name?: String;
  description?: String;
}

export interface DisqualificationUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface DisqualificationLinkUpdateInput {
  disqualification?: DisqualificationUpdateOneRequiredInput;
  createdBy?: UserUpdateOneRequiredInput;
  justification?: String;
}

export interface DisqualificationLinkUpdateManyMutationInput {
  justification?: String;
}

export interface EventUpdateInput {
  type?: EventType;
  actorType?: EventActorType;
  actorUser?: UserUpdateOneWithoutEventsInput;
  actorCandidate?: CandidateUpdateOneInput;
  targetType?: EventTargetType;
  targetCandidate?: CandidateUpdateOneWithoutEventsInput;
  targetJob?: JobUpdateOneWithoutEventsInput;
  targetTask?: TaskUpdateOneInput;
  targetWorkspace?: WorkspaceUpdateOneWithoutEventsInput;
}

export interface EventUpdateManyMutationInput {
  type?: EventType;
  actorType?: EventActorType;
  targetType?: EventTargetType;
}

export interface FieldUpdateInput {
  type?: FieldType;
  label?: String;
}

export interface FieldUpdateManyMutationInput {
  type?: FieldType;
  label?: String;
}

export interface FieldLinkUpdateInput {
  field?: FieldUpdateOneRequiredInput;
  value?: String;
}

export interface FieldLinkUpdateManyMutationInput {
  value?: String;
}

export interface FileUpdateInput {
  size?: Int;
  type?: String;
  name?: String;
  url?: String;
}

export interface FileUpdateManyMutationInput {
  size?: Int;
  type?: String;
  name?: String;
  url?: String;
}

export interface InviteUpdateInput {
  email?: String;
  expireAt?: DateTimeInput;
  invitedBy?: UserUpdateOneRequiredInput;
}

export interface InviteUpdateManyMutationInput {
  email?: String;
  expireAt?: DateTimeInput;
}

export interface JobCreateInput {
  workspace: WorkspaceCreateOneWithoutJobsInput;
  subscribers?: UserCreateManyWithoutSubscriptionJobsInput;
  events?: EventCreateManyWithoutTargetJobInput;
  applications?: ApplicationCreateManyWithoutJobInput;
  workflow: WorkflowCreateOneInput;
  comments?: CommentCreateManyInput;
  type: JobType;
  department?: String;
  locations?: LocationCreateManyInput;
  name: String;
  description?: String;
  requirements?: String;
}

export interface JobUpdateInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutJobsInput;
  subscribers?: UserUpdateManyWithoutSubscriptionJobsInput;
  events?: EventUpdateManyWithoutTargetJobInput;
  applications?: ApplicationUpdateManyWithoutJobInput;
  workflow?: WorkflowUpdateOneRequiredInput;
  comments?: CommentUpdateManyInput;
  type?: JobType;
  department?: String;
  locations?: LocationUpdateManyInput;
  name?: String;
  description?: String;
  requirements?: String;
}

export interface JobUpdateManyMutationInput {
  type?: JobType;
  department?: String;
  name?: String;
  description?: String;
  requirements?: String;
}

export interface LocationUpdateInput {
  country?: String;
  region?: String;
  city?: String;
  zip?: String;
}

export interface LocationUpdateManyMutationInput {
  country?: String;
  region?: String;
  city?: String;
  zip?: String;
}

export interface NotificationCreateInput {
  type: NotificationType;
  user: UserCreateOneWithoutNotificationsInput;
  event: EventCreateOneInput;
}

export interface UserCreateOneWithoutNotificationsInput {
  create?: UserCreateWithoutNotificationsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutNotificationsInput {
  workspace: WorkspaceCreateOneWithoutUsersInput;
  events?: EventCreateOneWithoutActorUserInput;
  subscriptionJobs?: JobCreateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateCreateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskCreateManyWithoutSubscribersInput;
  tasks?: TaskCreateManyWithoutOwnersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface NotificationUpdateInput {
  type?: NotificationType;
  user?: UserUpdateOneRequiredWithoutNotificationsInput;
  event?: EventUpdateOneRequiredInput;
}

export interface UserUpdateOneRequiredWithoutNotificationsInput {
  create?: UserCreateWithoutNotificationsInput;
  update?: UserUpdateWithoutNotificationsDataInput;
  upsert?: UserUpsertWithoutNotificationsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutNotificationsDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput;
  events?: EventUpdateOneWithoutActorUserInput;
  subscriptionJobs?: JobUpdateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateUpdateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskUpdateManyWithoutSubscribersInput;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput;
  create: UserCreateWithoutNotificationsInput;
}

export interface NotificationUpdateManyMutationInput {
  type?: NotificationType;
}

export interface StageUpdateInput {
  name?: String;
  description?: String;
  type?: StageType;
}

export interface StageUpdateManyMutationInput {
  name?: String;
  description?: String;
  type?: StageType;
}

export interface TagUpdateInput {
  label?: String;
}

export interface TagUpdateManyMutationInput {
  label?: String;
}

export interface TaskUpdateInput {
  subscribers?: UserUpdateManyWithoutSubscriptionTasksInput;
  owners?: UserUpdateManyWithoutTasksInput;
  candidate?: CandidateUpdateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface TaskUpdateManyMutationInput {
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserUpdateInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutUsersInput;
  events?: EventUpdateOneWithoutActorUserInput;
  notifications?: NotificationUpdateManyWithoutUserInput;
  subscriptionJobs?: JobUpdateManyWithoutSubscribersInput;
  subscriptionCandidates?: CandidateUpdateManyWithoutSubscribersInput;
  subscriptionTasks?: TaskUpdateManyWithoutSubscribersInput;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface UserUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
}

export interface WorkflowUpdateInput {
  name?: String;
  description?: String;
  stages?: StageUpdateManyInput;
  disqualifications?: DisqualificationUpdateManyInput;
  fields?: FieldUpdateManyInput;
}

export interface WorkflowUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface WorkspaceCreateInput {
  events?: EventCreateManyWithoutTargetWorkspaceInput;
  users?: UserCreateManyWithoutWorkspaceInput;
  jobs?: JobCreateManyWithoutWorkspaceInput;
  candidates?: CandidateCreateManyWithoutWorkspaceInput;
  workflows?: WorkflowCreateManyInput;
  workflowDefault?: WorkflowCreateOneInput;
  invites?: InviteCreateManyInput;
  tags?: TagCreateManyInput;
  name: String;
}

export interface WorkspaceUpdateInput {
  events?: EventUpdateManyWithoutTargetWorkspaceInput;
  users?: UserUpdateManyWithoutWorkspaceInput;
  jobs?: JobUpdateManyWithoutWorkspaceInput;
  candidates?: CandidateUpdateManyWithoutWorkspaceInput;
  workflows?: WorkflowUpdateManyInput;
  workflowDefault?: WorkflowUpdateOneInput;
  invites?: InviteUpdateManyInput;
  tags?: TagUpdateManyInput;
  name?: String;
}

export interface WorkspaceUpdateManyMutationInput {
  name?: String;
}

export interface ApplicationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ApplicationWhereInput;
  AND?: ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput;
  OR?: ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput;
  NOT?: ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput;
}

export interface CandidateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CandidateWhereInput;
  AND?: CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput;
  OR?: CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput;
  NOT?: CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface DisqualificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DisqualificationWhereInput;
  AND?:
    | DisqualificationSubscriptionWhereInput[]
    | DisqualificationSubscriptionWhereInput;
  OR?:
    | DisqualificationSubscriptionWhereInput[]
    | DisqualificationSubscriptionWhereInput;
  NOT?:
    | DisqualificationSubscriptionWhereInput[]
    | DisqualificationSubscriptionWhereInput;
}

export interface DisqualificationLinkSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DisqualificationLinkWhereInput;
  AND?:
    | DisqualificationLinkSubscriptionWhereInput[]
    | DisqualificationLinkSubscriptionWhereInput;
  OR?:
    | DisqualificationLinkSubscriptionWhereInput[]
    | DisqualificationLinkSubscriptionWhereInput;
  NOT?:
    | DisqualificationLinkSubscriptionWhereInput[]
    | DisqualificationLinkSubscriptionWhereInput;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface FieldSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FieldWhereInput;
  AND?: FieldSubscriptionWhereInput[] | FieldSubscriptionWhereInput;
  OR?: FieldSubscriptionWhereInput[] | FieldSubscriptionWhereInput;
  NOT?: FieldSubscriptionWhereInput[] | FieldSubscriptionWhereInput;
}

export interface FieldLinkSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FieldLinkWhereInput;
  AND?: FieldLinkSubscriptionWhereInput[] | FieldLinkSubscriptionWhereInput;
  OR?: FieldLinkSubscriptionWhereInput[] | FieldLinkSubscriptionWhereInput;
  NOT?: FieldLinkSubscriptionWhereInput[] | FieldLinkSubscriptionWhereInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface InviteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InviteWhereInput;
  AND?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
  OR?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
  NOT?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
}

export interface JobSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: JobWhereInput;
  AND?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
  OR?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
  NOT?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NotificationWhereInput;
  AND?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  OR?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
  NOT?:
    | NotificationSubscriptionWhereInput[]
    | NotificationSubscriptionWhereInput;
}

export interface StageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StageWhereInput;
  AND?: StageSubscriptionWhereInput[] | StageSubscriptionWhereInput;
  OR?: StageSubscriptionWhereInput[] | StageSubscriptionWhereInput;
  NOT?: StageSubscriptionWhereInput[] | StageSubscriptionWhereInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface TaskSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TaskWhereInput;
  AND?: TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput;
  OR?: TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput;
  NOT?: TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface WorkflowSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WorkflowWhereInput;
  AND?: WorkflowSubscriptionWhereInput[] | WorkflowSubscriptionWhereInput;
  OR?: WorkflowSubscriptionWhereInput[] | WorkflowSubscriptionWhereInput;
  NOT?: WorkflowSubscriptionWhereInput[] | WorkflowSubscriptionWhereInput;
}

export interface WorkspaceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WorkspaceWhereInput;
  AND?: WorkspaceSubscriptionWhereInput[] | WorkspaceSubscriptionWhereInput;
  OR?: WorkspaceSubscriptionWhereInput[] | WorkspaceSubscriptionWhereInput;
  NOT?: WorkspaceSubscriptionWhereInput[] | WorkspaceSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Application {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type: ApplicationType;
}

export interface ApplicationPromise extends Promise<Application>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ApplicationType>;
  disqualificationLink: <T = DisqualificationLinkPromise>() => T;
  stage: <T = StagePromise>() => T;
  job: <T = JobPromise>() => T;
  candidate: <T = CandidatePromise>() => T;
}

export interface ApplicationSubscription
  extends Promise<AsyncIterator<Application>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<ApplicationType>>;
  disqualificationLink: <T = DisqualificationLinkSubscription>() => T;
  stage: <T = StageSubscription>() => T;
  job: <T = JobSubscription>() => T;
  candidate: <T = CandidateSubscription>() => T;
}

export interface DisqualificationLink {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  justification?: String;
}

export interface DisqualificationLinkPromise
  extends Promise<DisqualificationLink>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  disqualification: <T = DisqualificationPromise>() => T;
  createdBy: <T = UserPromise>() => T;
  justification: () => Promise<String>;
}

export interface DisqualificationLinkSubscription
  extends Promise<AsyncIterator<DisqualificationLink>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  disqualification: <T = DisqualificationSubscription>() => T;
  createdBy: <T = UserSubscription>() => T;
  justification: () => Promise<AsyncIterator<String>>;
}

export interface Disqualification {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
}

export interface DisqualificationPromise
  extends Promise<Disqualification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface DisqualificationSubscription
  extends Promise<AsyncIterator<Disqualification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  position?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  workspace: <T = WorkspacePromise>() => T;
  events: <T = EventPromise>() => T;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subscriptionJobs: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subscriptionCandidates: <T = FragmentableArray<Candidate>>(args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subscriptionTasks: <T = FragmentableArray<Task>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tasks: <T = FragmentableArray<Task>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  lastLogin: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  position: () => Promise<String>;
  avatar: <T = FilePromise>() => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  workspace: <T = WorkspaceSubscription>() => T;
  events: <T = EventSubscription>() => T;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subscriptionJobs: <T = Promise<AsyncIterator<JobSubscription>>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subscriptionCandidates: <
    T = Promise<AsyncIterator<CandidateSubscription>>
  >(args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subscriptionTasks: <T = Promise<AsyncIterator<TaskSubscription>>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tasks: <T = Promise<AsyncIterator<TaskSubscription>>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  lastLogin: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  position: () => Promise<AsyncIterator<String>>;
  avatar: <T = FileSubscription>() => T;
}

export interface Workspace {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface WorkspacePromise extends Promise<Workspace>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  jobs: <T = FragmentableArray<Job>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  candidates: <T = FragmentableArray<Candidate>>(args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workflows: <T = FragmentableArray<Workflow>>(args?: {
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workflowDefault: <T = WorkflowPromise>() => T;
  invites: <T = FragmentableArray<Invite>>(args?: {
    where?: InviteWhereInput;
    orderBy?: InviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

export interface WorkspaceSubscription
  extends Promise<AsyncIterator<Workspace>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  jobs: <T = Promise<AsyncIterator<JobSubscription>>>(args?: {
    where?: JobWhereInput;
    orderBy?: JobOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  candidates: <T = Promise<AsyncIterator<CandidateSubscription>>>(args?: {
    where?: CandidateWhereInput;
    orderBy?: CandidateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workflows: <T = Promise<AsyncIterator<WorkflowSubscription>>>(args?: {
    where?: WorkflowWhereInput;
    orderBy?: WorkflowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workflowDefault: <T = WorkflowSubscription>() => T;
  invites: <T = Promise<AsyncIterator<InviteSubscription>>>(args?: {
    where?: InviteWhereInput;
    orderBy?: InviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Event {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: EventType;
  actorType: EventActorType;
  targetType: EventTargetType;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<EventType>;
  actorType: () => Promise<EventActorType>;
  actorUser: <T = UserPromise>() => T;
  actorCandidate: <T = CandidatePromise>() => T;
  targetType: () => Promise<EventTargetType>;
  targetCandidate: <T = CandidatePromise>() => T;
  targetJob: <T = JobPromise>() => T;
  targetTask: <T = TaskPromise>() => T;
  targetWorkspace: <T = WorkspacePromise>() => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<EventType>>;
  actorType: () => Promise<AsyncIterator<EventActorType>>;
  actorUser: <T = UserSubscription>() => T;
  actorCandidate: <T = CandidateSubscription>() => T;
  targetType: () => Promise<AsyncIterator<EventTargetType>>;
  targetCandidate: <T = CandidateSubscription>() => T;
  targetJob: <T = JobSubscription>() => T;
  targetTask: <T = TaskSubscription>() => T;
  targetWorkspace: <T = WorkspaceSubscription>() => T;
}

export interface Candidate {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  emails: String[];
  phones: String[];
  links: String[];
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString: String[];
  coverLettersString: String[];
  source: String[];
}

export interface CandidatePromise extends Promise<Candidate>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  workspace: <T = WorkspacePromise>() => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subscribers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  emails: () => Promise<String[]>;
  phones: () => Promise<String[]>;
  links: () => Promise<String[]>;
  avatar: <T = FilePromise>() => T;
  metaCompany: () => Promise<String>;
  metaHeadline: () => Promise<String>;
  metaPosition: () => Promise<String>;
  resumesString: () => Promise<String[]>;
  resumesFile: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  coverLettersString: () => Promise<String[]>;
  coverLettersFile: <T = FragmentableArray<File>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  source: () => Promise<String[]>;
  fields: <T = FragmentableArray<FieldLink>>(args?: {
    where?: FieldLinkWhereInput;
    orderBy?: FieldLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tasks: <T = FragmentableArray<Task>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CandidateSubscription
  extends Promise<AsyncIterator<Candidate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  workspace: <T = WorkspaceSubscription>() => T;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  subscribers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  emails: () => Promise<AsyncIterator<String[]>>;
  phones: () => Promise<AsyncIterator<String[]>>;
  links: () => Promise<AsyncIterator<String[]>>;
  avatar: <T = FileSubscription>() => T;
  metaCompany: () => Promise<AsyncIterator<String>>;
  metaHeadline: () => Promise<AsyncIterator<String>>;
  metaPosition: () => Promise<AsyncIterator<String>>;
  resumesString: () => Promise<AsyncIterator<String[]>>;
  resumesFile: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  coverLettersString: () => Promise<AsyncIterator<String[]>>;
  coverLettersFile: <T = Promise<AsyncIterator<FileSubscription>>>(args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  source: () => Promise<AsyncIterator<String[]>>;
  fields: <T = Promise<AsyncIterator<FieldLinkSubscription>>>(args?: {
    where?: FieldLinkWhereInput;
    orderBy?: FieldLinkOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tasks: <T = Promise<AsyncIterator<TaskSubscription>>>(args?: {
    where?: TaskWhereInput;
    orderBy?: TaskOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface File {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  size: Int;
  type: String;
  name: String;
  url: String;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  size: () => Promise<Int>;
  type: () => Promise<String>;
  name: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  size: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface Tag {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  label: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  label: () => Promise<String>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface FieldLink {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  value?: String;
}

export interface FieldLinkPromise extends Promise<FieldLink>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  field: <T = FieldPromise>() => T;
  value: () => Promise<String>;
}

export interface FieldLinkSubscription
  extends Promise<AsyncIterator<FieldLink>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  field: <T = FieldSubscription>() => T;
  value: () => Promise<AsyncIterator<String>>;
}

export interface Field {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: FieldType;
  label: String;
}

export interface FieldPromise extends Promise<Field>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<FieldType>;
  label: () => Promise<String>;
}

export interface FieldSubscription
  extends Promise<AsyncIterator<Field>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<FieldType>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface Task {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  dueAt?: DateTimeOutput;
}

export interface TaskPromise extends Promise<Task>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  subscribers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owners: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  candidate: <T = CandidatePromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  dueAt: () => Promise<DateTimeOutput>;
}

export interface TaskSubscription
  extends Promise<AsyncIterator<Task>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  subscribers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owners: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  candidate: <T = CandidateSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  dueAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Comment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  content: String;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  parent: <T = CommentPromise>() => T;
  content: () => Promise<String>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
  parent: <T = CommentSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
}

export interface Job {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: JobType;
  department?: String;
  name: String;
  description?: String;
  requirements?: String;
}

export interface JobPromise extends Promise<Job>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  workspace: <T = WorkspacePromise>() => T;
  subscribers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workflow: <T = WorkflowPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<JobType>;
  department: () => Promise<String>;
  locations: <T = FragmentableArray<Location>>(args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  requirements: () => Promise<String>;
}

export interface JobSubscription
  extends Promise<AsyncIterator<Job>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  workspace: <T = WorkspaceSubscription>() => T;
  subscribers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  workflow: <T = WorkflowSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  type: () => Promise<AsyncIterator<JobType>>;
  department: () => Promise<AsyncIterator<String>>;
  locations: <T = Promise<AsyncIterator<LocationSubscription>>>(args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  requirements: () => Promise<AsyncIterator<String>>;
}

export interface Workflow {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
}

export interface WorkflowPromise extends Promise<Workflow>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  stages: <T = FragmentableArray<Stage>>(args?: {
    where?: StageWhereInput;
    orderBy?: StageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  disqualifications: <T = FragmentableArray<Disqualification>>(args?: {
    where?: DisqualificationWhereInput;
    orderBy?: DisqualificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fields: <T = FragmentableArray<Field>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface WorkflowSubscription
  extends Promise<AsyncIterator<Workflow>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  stages: <T = Promise<AsyncIterator<StageSubscription>>>(args?: {
    where?: StageWhereInput;
    orderBy?: StageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  disqualifications: <
    T = Promise<AsyncIterator<DisqualificationSubscription>>
  >(args?: {
    where?: DisqualificationWhereInput;
    orderBy?: DisqualificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fields: <T = Promise<AsyncIterator<FieldSubscription>>>(args?: {
    where?: FieldWhereInput;
    orderBy?: FieldOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Stage {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
  type: StageType;
}

export interface StagePromise extends Promise<Stage>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<StageType>;
}

export interface StageSubscription
  extends Promise<AsyncIterator<Stage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<StageType>>;
}

export interface Location {
  id: ID_Output;
  country: String;
  region: String;
  city: String;
  zip: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  country: () => Promise<String>;
  region: () => Promise<String>;
  city: () => Promise<String>;
  zip: () => Promise<String>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  country: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface Invite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  expireAt: DateTimeOutput;
}

export interface InvitePromise extends Promise<Invite>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  expireAt: () => Promise<DateTimeOutput>;
  invitedBy: <T = UserPromise>() => T;
}

export interface InviteSubscription
  extends Promise<AsyncIterator<Invite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  expireAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  invitedBy: <T = UserSubscription>() => T;
}

export interface Notification {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: NotificationType;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NotificationType>;
  user: <T = UserPromise>() => T;
  event: <T = EventPromise>() => T;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NotificationType>>;
  user: <T = UserSubscription>() => T;
  event: <T = EventSubscription>() => T;
}

export interface ApplicationConnection {
  pageInfo: PageInfo;
  edges: ApplicationEdge[];
}

export interface ApplicationConnectionPromise
  extends Promise<ApplicationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationEdge>>() => T;
  aggregate: <T = AggregateApplicationPromise>() => T;
}

export interface ApplicationConnectionSubscription
  extends Promise<AsyncIterator<ApplicationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicationSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationEdge {
  node: Application;
  cursor: String;
}

export interface ApplicationEdgePromise
  extends Promise<ApplicationEdge>,
    Fragmentable {
  node: <T = ApplicationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationEdgeSubscription
  extends Promise<AsyncIterator<ApplicationEdge>>,
    Fragmentable {
  node: <T = ApplicationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApplication {
  count: Int;
}

export interface AggregateApplicationPromise
  extends Promise<AggregateApplication>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationSubscription
  extends Promise<AsyncIterator<AggregateApplication>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CandidateConnection {
  pageInfo: PageInfo;
  edges: CandidateEdge[];
}

export interface CandidateConnectionPromise
  extends Promise<CandidateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CandidateEdge>>() => T;
  aggregate: <T = AggregateCandidatePromise>() => T;
}

export interface CandidateConnectionSubscription
  extends Promise<AsyncIterator<CandidateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CandidateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCandidateSubscription>() => T;
}

export interface CandidateEdge {
  node: Candidate;
  cursor: String;
}

export interface CandidateEdgePromise
  extends Promise<CandidateEdge>,
    Fragmentable {
  node: <T = CandidatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CandidateEdgeSubscription
  extends Promise<AsyncIterator<CandidateEdge>>,
    Fragmentable {
  node: <T = CandidateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCandidate {
  count: Int;
}

export interface AggregateCandidatePromise
  extends Promise<AggregateCandidate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCandidateSubscription
  extends Promise<AsyncIterator<AggregateCandidate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DisqualificationConnection {
  pageInfo: PageInfo;
  edges: DisqualificationEdge[];
}

export interface DisqualificationConnectionPromise
  extends Promise<DisqualificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DisqualificationEdge>>() => T;
  aggregate: <T = AggregateDisqualificationPromise>() => T;
}

export interface DisqualificationConnectionSubscription
  extends Promise<AsyncIterator<DisqualificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DisqualificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDisqualificationSubscription>() => T;
}

export interface DisqualificationEdge {
  node: Disqualification;
  cursor: String;
}

export interface DisqualificationEdgePromise
  extends Promise<DisqualificationEdge>,
    Fragmentable {
  node: <T = DisqualificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DisqualificationEdgeSubscription
  extends Promise<AsyncIterator<DisqualificationEdge>>,
    Fragmentable {
  node: <T = DisqualificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDisqualification {
  count: Int;
}

export interface AggregateDisqualificationPromise
  extends Promise<AggregateDisqualification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDisqualificationSubscription
  extends Promise<AsyncIterator<AggregateDisqualification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DisqualificationLinkConnection {
  pageInfo: PageInfo;
  edges: DisqualificationLinkEdge[];
}

export interface DisqualificationLinkConnectionPromise
  extends Promise<DisqualificationLinkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DisqualificationLinkEdge>>() => T;
  aggregate: <T = AggregateDisqualificationLinkPromise>() => T;
}

export interface DisqualificationLinkConnectionSubscription
  extends Promise<AsyncIterator<DisqualificationLinkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<DisqualificationLinkEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateDisqualificationLinkSubscription>() => T;
}

export interface DisqualificationLinkEdge {
  node: DisqualificationLink;
  cursor: String;
}

export interface DisqualificationLinkEdgePromise
  extends Promise<DisqualificationLinkEdge>,
    Fragmentable {
  node: <T = DisqualificationLinkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DisqualificationLinkEdgeSubscription
  extends Promise<AsyncIterator<DisqualificationLinkEdge>>,
    Fragmentable {
  node: <T = DisqualificationLinkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDisqualificationLink {
  count: Int;
}

export interface AggregateDisqualificationLinkPromise
  extends Promise<AggregateDisqualificationLink>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDisqualificationLinkSubscription
  extends Promise<AsyncIterator<AggregateDisqualificationLink>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldConnection {
  pageInfo: PageInfo;
  edges: FieldEdge[];
}

export interface FieldConnectionPromise
  extends Promise<FieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FieldEdge>>() => T;
  aggregate: <T = AggregateFieldPromise>() => T;
}

export interface FieldConnectionSubscription
  extends Promise<AsyncIterator<FieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldSubscription>() => T;
}

export interface FieldEdge {
  node: Field;
  cursor: String;
}

export interface FieldEdgePromise extends Promise<FieldEdge>, Fragmentable {
  node: <T = FieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FieldEdgeSubscription
  extends Promise<AsyncIterator<FieldEdge>>,
    Fragmentable {
  node: <T = FieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateField {
  count: Int;
}

export interface AggregateFieldPromise
  extends Promise<AggregateField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldSubscription
  extends Promise<AsyncIterator<AggregateField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldLinkConnection {
  pageInfo: PageInfo;
  edges: FieldLinkEdge[];
}

export interface FieldLinkConnectionPromise
  extends Promise<FieldLinkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FieldLinkEdge>>() => T;
  aggregate: <T = AggregateFieldLinkPromise>() => T;
}

export interface FieldLinkConnectionSubscription
  extends Promise<AsyncIterator<FieldLinkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldLinkEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldLinkSubscription>() => T;
}

export interface FieldLinkEdge {
  node: FieldLink;
  cursor: String;
}

export interface FieldLinkEdgePromise
  extends Promise<FieldLinkEdge>,
    Fragmentable {
  node: <T = FieldLinkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FieldLinkEdgeSubscription
  extends Promise<AsyncIterator<FieldLinkEdge>>,
    Fragmentable {
  node: <T = FieldLinkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFieldLink {
  count: Int;
}

export interface AggregateFieldLinkPromise
  extends Promise<AggregateFieldLink>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldLinkSubscription
  extends Promise<AsyncIterator<AggregateFieldLink>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InviteConnection {
  pageInfo: PageInfo;
  edges: InviteEdge[];
}

export interface InviteConnectionPromise
  extends Promise<InviteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InviteEdge>>() => T;
  aggregate: <T = AggregateInvitePromise>() => T;
}

export interface InviteConnectionSubscription
  extends Promise<AsyncIterator<InviteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InviteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInviteSubscription>() => T;
}

export interface InviteEdge {
  node: Invite;
  cursor: String;
}

export interface InviteEdgePromise extends Promise<InviteEdge>, Fragmentable {
  node: <T = InvitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InviteEdgeSubscription
  extends Promise<AsyncIterator<InviteEdge>>,
    Fragmentable {
  node: <T = InviteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvite {
  count: Int;
}

export interface AggregateInvitePromise
  extends Promise<AggregateInvite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInviteSubscription
  extends Promise<AsyncIterator<AggregateInvite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JobConnection {
  pageInfo: PageInfo;
  edges: JobEdge[];
}

export interface JobConnectionPromise
  extends Promise<JobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobEdge>>() => T;
  aggregate: <T = AggregateJobPromise>() => T;
}

export interface JobConnectionSubscription
  extends Promise<AsyncIterator<JobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobSubscription>() => T;
}

export interface JobEdge {
  node: Job;
  cursor: String;
}

export interface JobEdgePromise extends Promise<JobEdge>, Fragmentable {
  node: <T = JobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobEdgeSubscription
  extends Promise<AsyncIterator<JobEdge>>,
    Fragmentable {
  node: <T = JobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJob {
  count: Int;
}

export interface AggregateJobPromise
  extends Promise<AggregateJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobSubscription
  extends Promise<AsyncIterator<AggregateJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StageConnection {
  pageInfo: PageInfo;
  edges: StageEdge[];
}

export interface StageConnectionPromise
  extends Promise<StageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StageEdge>>() => T;
  aggregate: <T = AggregateStagePromise>() => T;
}

export interface StageConnectionSubscription
  extends Promise<AsyncIterator<StageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStageSubscription>() => T;
}

export interface StageEdge {
  node: Stage;
  cursor: String;
}

export interface StageEdgePromise extends Promise<StageEdge>, Fragmentable {
  node: <T = StagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface StageEdgeSubscription
  extends Promise<AsyncIterator<StageEdge>>,
    Fragmentable {
  node: <T = StageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStage {
  count: Int;
}

export interface AggregateStagePromise
  extends Promise<AggregateStage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStageSubscription
  extends Promise<AsyncIterator<AggregateStage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TaskConnection {
  pageInfo: PageInfo;
  edges: TaskEdge[];
}

export interface TaskConnectionPromise
  extends Promise<TaskConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TaskEdge>>() => T;
  aggregate: <T = AggregateTaskPromise>() => T;
}

export interface TaskConnectionSubscription
  extends Promise<AsyncIterator<TaskConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TaskEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTaskSubscription>() => T;
}

export interface TaskEdge {
  node: Task;
  cursor: String;
}

export interface TaskEdgePromise extends Promise<TaskEdge>, Fragmentable {
  node: <T = TaskPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TaskEdgeSubscription
  extends Promise<AsyncIterator<TaskEdge>>,
    Fragmentable {
  node: <T = TaskSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTask {
  count: Int;
}

export interface AggregateTaskPromise
  extends Promise<AggregateTask>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTaskSubscription
  extends Promise<AsyncIterator<AggregateTask>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkflowConnection {
  pageInfo: PageInfo;
  edges: WorkflowEdge[];
}

export interface WorkflowConnectionPromise
  extends Promise<WorkflowConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkflowEdge>>() => T;
  aggregate: <T = AggregateWorkflowPromise>() => T;
}

export interface WorkflowConnectionSubscription
  extends Promise<AsyncIterator<WorkflowConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkflowEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkflowSubscription>() => T;
}

export interface WorkflowEdge {
  node: Workflow;
  cursor: String;
}

export interface WorkflowEdgePromise
  extends Promise<WorkflowEdge>,
    Fragmentable {
  node: <T = WorkflowPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkflowEdgeSubscription
  extends Promise<AsyncIterator<WorkflowEdge>>,
    Fragmentable {
  node: <T = WorkflowSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkflow {
  count: Int;
}

export interface AggregateWorkflowPromise
  extends Promise<AggregateWorkflow>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkflowSubscription
  extends Promise<AsyncIterator<AggregateWorkflow>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkspaceConnection {
  pageInfo: PageInfo;
  edges: WorkspaceEdge[];
}

export interface WorkspaceConnectionPromise
  extends Promise<WorkspaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkspaceEdge>>() => T;
  aggregate: <T = AggregateWorkspacePromise>() => T;
}

export interface WorkspaceConnectionSubscription
  extends Promise<AsyncIterator<WorkspaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkspaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkspaceSubscription>() => T;
}

export interface WorkspaceEdge {
  node: Workspace;
  cursor: String;
}

export interface WorkspaceEdgePromise
  extends Promise<WorkspaceEdge>,
    Fragmentable {
  node: <T = WorkspacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkspaceEdgeSubscription
  extends Promise<AsyncIterator<WorkspaceEdge>>,
    Fragmentable {
  node: <T = WorkspaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkspace {
  count: Int;
}

export interface AggregateWorkspacePromise
  extends Promise<AggregateWorkspace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkspaceSubscription
  extends Promise<AsyncIterator<AggregateWorkspace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ApplicationSubscriptionPayload {
  mutation: MutationType;
  node: Application;
  updatedFields: String[];
  previousValues: ApplicationPreviousValues;
}

export interface ApplicationSubscriptionPayloadPromise
  extends Promise<ApplicationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationPreviousValuesPromise>() => T;
}

export interface ApplicationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicationPreviousValuesSubscription>() => T;
}

export interface ApplicationPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type: ApplicationType;
}

export interface ApplicationPreviousValuesPromise
  extends Promise<ApplicationPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ApplicationType>;
}

export interface ApplicationPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<ApplicationType>>;
}

export interface CandidateSubscriptionPayload {
  mutation: MutationType;
  node: Candidate;
  updatedFields: String[];
  previousValues: CandidatePreviousValues;
}

export interface CandidateSubscriptionPayloadPromise
  extends Promise<CandidateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CandidatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CandidatePreviousValuesPromise>() => T;
}

export interface CandidateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CandidateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CandidateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CandidatePreviousValuesSubscription>() => T;
}

export interface CandidatePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  emails: String[];
  phones: String[];
  links: String[];
  metaCompany?: String;
  metaHeadline?: String;
  metaPosition?: String;
  resumesString: String[];
  coverLettersString: String[];
  source: String[];
}

export interface CandidatePreviousValuesPromise
  extends Promise<CandidatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  emails: () => Promise<String[]>;
  phones: () => Promise<String[]>;
  links: () => Promise<String[]>;
  metaCompany: () => Promise<String>;
  metaHeadline: () => Promise<String>;
  metaPosition: () => Promise<String>;
  resumesString: () => Promise<String[]>;
  coverLettersString: () => Promise<String[]>;
  source: () => Promise<String[]>;
}

export interface CandidatePreviousValuesSubscription
  extends Promise<AsyncIterator<CandidatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  emails: () => Promise<AsyncIterator<String[]>>;
  phones: () => Promise<AsyncIterator<String[]>>;
  links: () => Promise<AsyncIterator<String[]>>;
  metaCompany: () => Promise<AsyncIterator<String>>;
  metaHeadline: () => Promise<AsyncIterator<String>>;
  metaPosition: () => Promise<AsyncIterator<String>>;
  resumesString: () => Promise<AsyncIterator<String[]>>;
  coverLettersString: () => Promise<AsyncIterator<String[]>>;
  source: () => Promise<AsyncIterator<String[]>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  content: String;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface DisqualificationSubscriptionPayload {
  mutation: MutationType;
  node: Disqualification;
  updatedFields: String[];
  previousValues: DisqualificationPreviousValues;
}

export interface DisqualificationSubscriptionPayloadPromise
  extends Promise<DisqualificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DisqualificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DisqualificationPreviousValuesPromise>() => T;
}

export interface DisqualificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DisqualificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DisqualificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DisqualificationPreviousValuesSubscription>() => T;
}

export interface DisqualificationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
}

export interface DisqualificationPreviousValuesPromise
  extends Promise<DisqualificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface DisqualificationPreviousValuesSubscription
  extends Promise<AsyncIterator<DisqualificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface DisqualificationLinkSubscriptionPayload {
  mutation: MutationType;
  node: DisqualificationLink;
  updatedFields: String[];
  previousValues: DisqualificationLinkPreviousValues;
}

export interface DisqualificationLinkSubscriptionPayloadPromise
  extends Promise<DisqualificationLinkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DisqualificationLinkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DisqualificationLinkPreviousValuesPromise>() => T;
}

export interface DisqualificationLinkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DisqualificationLinkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DisqualificationLinkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DisqualificationLinkPreviousValuesSubscription>() => T;
}

export interface DisqualificationLinkPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  justification?: String;
}

export interface DisqualificationLinkPreviousValuesPromise
  extends Promise<DisqualificationLinkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  justification: () => Promise<String>;
}

export interface DisqualificationLinkPreviousValuesSubscription
  extends Promise<AsyncIterator<DisqualificationLinkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  justification: () => Promise<AsyncIterator<String>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: EventType;
  actorType: EventActorType;
  targetType: EventTargetType;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<EventType>;
  actorType: () => Promise<EventActorType>;
  targetType: () => Promise<EventTargetType>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<EventType>>;
  actorType: () => Promise<AsyncIterator<EventActorType>>;
  targetType: () => Promise<AsyncIterator<EventTargetType>>;
}

export interface FieldSubscriptionPayload {
  mutation: MutationType;
  node: Field;
  updatedFields: String[];
  previousValues: FieldPreviousValues;
}

export interface FieldSubscriptionPayloadPromise
  extends Promise<FieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldPreviousValuesPromise>() => T;
}

export interface FieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldPreviousValuesSubscription>() => T;
}

export interface FieldPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: FieldType;
  label: String;
}

export interface FieldPreviousValuesPromise
  extends Promise<FieldPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<FieldType>;
  label: () => Promise<String>;
}

export interface FieldPreviousValuesSubscription
  extends Promise<AsyncIterator<FieldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<FieldType>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface FieldLinkSubscriptionPayload {
  mutation: MutationType;
  node: FieldLink;
  updatedFields: String[];
  previousValues: FieldLinkPreviousValues;
}

export interface FieldLinkSubscriptionPayloadPromise
  extends Promise<FieldLinkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldLinkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldLinkPreviousValuesPromise>() => T;
}

export interface FieldLinkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldLinkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldLinkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldLinkPreviousValuesSubscription>() => T;
}

export interface FieldLinkPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  value?: String;
}

export interface FieldLinkPreviousValuesPromise
  extends Promise<FieldLinkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface FieldLinkPreviousValuesSubscription
  extends Promise<AsyncIterator<FieldLinkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  size: Int;
  type: String;
  name: String;
  url: String;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  size: () => Promise<Int>;
  type: () => Promise<String>;
  name: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  size: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface InviteSubscriptionPayload {
  mutation: MutationType;
  node: Invite;
  updatedFields: String[];
  previousValues: InvitePreviousValues;
}

export interface InviteSubscriptionPayloadPromise
  extends Promise<InviteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvitePreviousValuesPromise>() => T;
}

export interface InviteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InviteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InviteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvitePreviousValuesSubscription>() => T;
}

export interface InvitePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  expireAt: DateTimeOutput;
}

export interface InvitePreviousValuesPromise
  extends Promise<InvitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  expireAt: () => Promise<DateTimeOutput>;
}

export interface InvitePreviousValuesSubscription
  extends Promise<AsyncIterator<InvitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  expireAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JobSubscriptionPayload {
  mutation: MutationType;
  node: Job;
  updatedFields: String[];
  previousValues: JobPreviousValues;
}

export interface JobSubscriptionPayloadPromise
  extends Promise<JobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPreviousValuesPromise>() => T;
}

export interface JobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPreviousValuesSubscription>() => T;
}

export interface JobPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: JobType;
  department?: String;
  name: String;
  description?: String;
  requirements?: String;
}

export interface JobPreviousValuesPromise
  extends Promise<JobPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<JobType>;
  department: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  requirements: () => Promise<String>;
}

export interface JobPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<JobType>>;
  department: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  requirements: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  country: String;
  region: String;
  city: String;
  zip: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  country: () => Promise<String>;
  region: () => Promise<String>;
  city: () => Promise<String>;
  zip: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  country: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: NotificationType;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<NotificationType>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<NotificationType>>;
}

export interface StageSubscriptionPayload {
  mutation: MutationType;
  node: Stage;
  updatedFields: String[];
  previousValues: StagePreviousValues;
}

export interface StageSubscriptionPayloadPromise
  extends Promise<StageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StagePreviousValuesPromise>() => T;
}

export interface StageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StagePreviousValuesSubscription>() => T;
}

export interface StagePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
  type: StageType;
}

export interface StagePreviousValuesPromise
  extends Promise<StagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<StageType>;
}

export interface StagePreviousValuesSubscription
  extends Promise<AsyncIterator<StagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<StageType>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  label: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  label: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface TaskSubscriptionPayload {
  mutation: MutationType;
  node: Task;
  updatedFields: String[];
  previousValues: TaskPreviousValues;
}

export interface TaskSubscriptionPayloadPromise
  extends Promise<TaskSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TaskPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TaskPreviousValuesPromise>() => T;
}

export interface TaskSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TaskSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TaskSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TaskPreviousValuesSubscription>() => T;
}

export interface TaskPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  dueAt?: DateTimeOutput;
}

export interface TaskPreviousValuesPromise
  extends Promise<TaskPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  dueAt: () => Promise<DateTimeOutput>;
}

export interface TaskPreviousValuesSubscription
  extends Promise<AsyncIterator<TaskPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  dueAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  position?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  lastLogin: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  position: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  lastLogin: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  position: () => Promise<AsyncIterator<String>>;
}

export interface WorkflowSubscriptionPayload {
  mutation: MutationType;
  node: Workflow;
  updatedFields: String[];
  previousValues: WorkflowPreviousValues;
}

export interface WorkflowSubscriptionPayloadPromise
  extends Promise<WorkflowSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkflowPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkflowPreviousValuesPromise>() => T;
}

export interface WorkflowSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkflowSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkflowSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkflowPreviousValuesSubscription>() => T;
}

export interface WorkflowPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
}

export interface WorkflowPreviousValuesPromise
  extends Promise<WorkflowPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface WorkflowPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkflowPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface WorkspaceSubscriptionPayload {
  mutation: MutationType;
  node: Workspace;
  updatedFields: String[];
  previousValues: WorkspacePreviousValues;
}

export interface WorkspaceSubscriptionPayloadPromise
  extends Promise<WorkspaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkspacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkspacePreviousValuesPromise>() => T;
}

export interface WorkspaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkspaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkspaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkspacePreviousValuesSubscription>() => T;
}

export interface WorkspacePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface WorkspacePreviousValuesPromise
  extends Promise<WorkspacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface WorkspacePreviousValuesSubscription
  extends Promise<AsyncIterator<WorkspacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Application",
    embedded: false
  },
  {
    name: "ApplicationType",
    embedded: false
  },
  {
    name: "Candidate",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Disqualification",
    embedded: false
  },
  {
    name: "DisqualificationLink",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "EventActorType",
    embedded: false
  },
  {
    name: "EventTargetType",
    embedded: false
  },
  {
    name: "EventType",
    embedded: false
  },
  {
    name: "Field",
    embedded: false
  },
  {
    name: "FieldLink",
    embedded: false
  },
  {
    name: "FieldType",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Invite",
    embedded: false
  },
  {
    name: "Job",
    embedded: false
  },
  {
    name: "JobType",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "NotificationType",
    embedded: false
  },
  {
    name: "Stage",
    embedded: false
  },
  {
    name: "StageType",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Task",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Workflow",
    embedded: false
  },
  {
    name: "Workspace",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}/${
    process.env["PRISMA_SERVICE"]
  }/${process.env["PRISMA_STAGE"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
