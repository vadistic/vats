// Code generated by Prisma (prisma@1.27.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  application: (where?: ApplicationWhereInput) => Promise<boolean>;
  candidate: (where?: CandidateWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  disqualification: (where?: DisqualificationWhereInput) => Promise<boolean>;
  disqualificationInstance: (
    where?: DisqualificationInstanceWhereInput
  ) => Promise<boolean>;
  field: (where?: FieldWhereInput) => Promise<boolean>;
  fieldInstance: (where?: FieldInstanceWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  invite: (where?: InviteWhereInput) => Promise<boolean>;
  job: (where?: JobWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  source: (where?: SourceWhereInput) => Promise<boolean>;
  stage: (where?: StageWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  task: (where?: TaskWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  workflow: (where?: WorkflowWhereInput) => Promise<boolean>;
  workspace: (where?: WorkspaceWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  application: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  applications: (
    args?: {
      where?: ApplicationWhereInput;
      orderBy?: ApplicationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Application>;
  applicationsConnection: (
    args?: {
      where?: ApplicationWhereInput;
      orderBy?: ApplicationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ApplicationConnectionPromise;
  candidate: (where: CandidateWhereUniqueInput) => CandidatePromise;
  candidates: (
    args?: {
      where?: CandidateWhereInput;
      orderBy?: CandidateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Candidate>;
  candidatesConnection: (
    args?: {
      where?: CandidateWhereInput;
      orderBy?: CandidateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CandidateConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  disqualification: (
    where: DisqualificationWhereUniqueInput
  ) => DisqualificationPromise;
  disqualifications: (
    args?: {
      where?: DisqualificationWhereInput;
      orderBy?: DisqualificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Disqualification>;
  disqualificationsConnection: (
    args?: {
      where?: DisqualificationWhereInput;
      orderBy?: DisqualificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DisqualificationConnectionPromise;
  disqualificationInstance: (
    where: DisqualificationInstanceWhereUniqueInput
  ) => DisqualificationInstancePromise;
  disqualificationInstances: (
    args?: {
      where?: DisqualificationInstanceWhereInput;
      orderBy?: DisqualificationInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DisqualificationInstance>;
  disqualificationInstancesConnection: (
    args?: {
      where?: DisqualificationInstanceWhereInput;
      orderBy?: DisqualificationInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DisqualificationInstanceConnectionPromise;
  field: (where: FieldWhereUniqueInput) => FieldPromise;
  fields: (
    args?: {
      where?: FieldWhereInput;
      orderBy?: FieldOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Field>;
  fieldsConnection: (
    args?: {
      where?: FieldWhereInput;
      orderBy?: FieldOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FieldConnectionPromise;
  fieldInstance: (where: FieldInstanceWhereUniqueInput) => FieldInstancePromise;
  fieldInstances: (
    args?: {
      where?: FieldInstanceWhereInput;
      orderBy?: FieldInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FieldInstance>;
  fieldInstancesConnection: (
    args?: {
      where?: FieldInstanceWhereInput;
      orderBy?: FieldInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FieldInstanceConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<File>;
  filesConnection: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FileConnectionPromise;
  invite: (where: InviteWhereUniqueInput) => InvitePromise;
  invites: (
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Invite>;
  invitesConnection: (
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InviteConnectionPromise;
  job: (where: JobWhereUniqueInput) => JobPromise;
  jobs: (
    args?: {
      where?: JobWhereInput;
      orderBy?: JobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Job>;
  jobsConnection: (
    args?: {
      where?: JobWhereInput;
      orderBy?: JobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => JobConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationPromise;
  locations: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Location>;
  locationsConnection: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationConnectionPromise;
  source: (where: SourceWhereUniqueInput) => SourcePromise;
  sources: (
    args?: {
      where?: SourceWhereInput;
      orderBy?: SourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Source>;
  sourcesConnection: (
    args?: {
      where?: SourceWhereInput;
      orderBy?: SourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SourceConnectionPromise;
  stage: (where: StageWhereUniqueInput) => StagePromise;
  stages: (
    args?: {
      where?: StageWhereInput;
      orderBy?: StageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Stage>;
  stagesConnection: (
    args?: {
      where?: StageWhereInput;
      orderBy?: StageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StageConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  task: (where: TaskWhereUniqueInput) => TaskPromise;
  tasks: (
    args?: {
      where?: TaskWhereInput;
      orderBy?: TaskOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Task>;
  tasksConnection: (
    args?: {
      where?: TaskWhereInput;
      orderBy?: TaskOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TaskConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  workflow: (where: WorkflowWhereUniqueInput) => WorkflowPromise;
  workflows: (
    args?: {
      where?: WorkflowWhereInput;
      orderBy?: WorkflowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Workflow>;
  workflowsConnection: (
    args?: {
      where?: WorkflowWhereInput;
      orderBy?: WorkflowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WorkflowConnectionPromise;
  workspace: (where: WorkspaceWhereUniqueInput) => WorkspacePromise;
  workspaces: (
    args?: {
      where?: WorkspaceWhereInput;
      orderBy?: WorkspaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Workspace>;
  workspacesConnection: (
    args?: {
      where?: WorkspaceWhereInput;
      orderBy?: WorkspaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WorkspaceConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApplication: (data: ApplicationCreateInput) => ApplicationPromise;
  updateApplication: (
    args: { data: ApplicationUpdateInput; where: ApplicationWhereUniqueInput }
  ) => ApplicationPromise;
  updateManyApplications: (
    args: {
      data: ApplicationUpdateManyMutationInput;
      where?: ApplicationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertApplication: (
    args: {
      where: ApplicationWhereUniqueInput;
      create: ApplicationCreateInput;
      update: ApplicationUpdateInput;
    }
  ) => ApplicationPromise;
  deleteApplication: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  deleteManyApplications: (
    where?: ApplicationWhereInput
  ) => BatchPayloadPromise;
  createCandidate: (data: CandidateCreateInput) => CandidatePromise;
  updateCandidate: (
    args: { data: CandidateUpdateInput; where: CandidateWhereUniqueInput }
  ) => CandidatePromise;
  updateManyCandidates: (
    args: {
      data: CandidateUpdateManyMutationInput;
      where?: CandidateWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCandidate: (
    args: {
      where: CandidateWhereUniqueInput;
      create: CandidateCreateInput;
      update: CandidateUpdateInput;
    }
  ) => CandidatePromise;
  deleteCandidate: (where: CandidateWhereUniqueInput) => CandidatePromise;
  deleteManyCandidates: (where?: CandidateWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  updateManyComments: (
    args: { data: CommentUpdateManyMutationInput; where?: CommentWhereInput }
  ) => BatchPayloadPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createDisqualification: (
    data: DisqualificationCreateInput
  ) => DisqualificationPromise;
  updateDisqualification: (
    args: {
      data: DisqualificationUpdateInput;
      where: DisqualificationWhereUniqueInput;
    }
  ) => DisqualificationPromise;
  updateManyDisqualifications: (
    args: {
      data: DisqualificationUpdateManyMutationInput;
      where?: DisqualificationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDisqualification: (
    args: {
      where: DisqualificationWhereUniqueInput;
      create: DisqualificationCreateInput;
      update: DisqualificationUpdateInput;
    }
  ) => DisqualificationPromise;
  deleteDisqualification: (
    where: DisqualificationWhereUniqueInput
  ) => DisqualificationPromise;
  deleteManyDisqualifications: (
    where?: DisqualificationWhereInput
  ) => BatchPayloadPromise;
  createDisqualificationInstance: (
    data: DisqualificationInstanceCreateInput
  ) => DisqualificationInstancePromise;
  updateDisqualificationInstance: (
    args: {
      data: DisqualificationInstanceUpdateInput;
      where: DisqualificationInstanceWhereUniqueInput;
    }
  ) => DisqualificationInstancePromise;
  updateManyDisqualificationInstances: (
    args: {
      data: DisqualificationInstanceUpdateManyMutationInput;
      where?: DisqualificationInstanceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDisqualificationInstance: (
    args: {
      where: DisqualificationInstanceWhereUniqueInput;
      create: DisqualificationInstanceCreateInput;
      update: DisqualificationInstanceUpdateInput;
    }
  ) => DisqualificationInstancePromise;
  deleteDisqualificationInstance: (
    where: DisqualificationInstanceWhereUniqueInput
  ) => DisqualificationInstancePromise;
  deleteManyDisqualificationInstances: (
    where?: DisqualificationInstanceWhereInput
  ) => BatchPayloadPromise;
  createField: (data: FieldCreateInput) => FieldPromise;
  updateField: (
    args: { data: FieldUpdateInput; where: FieldWhereUniqueInput }
  ) => FieldPromise;
  updateManyFields: (
    args: { data: FieldUpdateManyMutationInput; where?: FieldWhereInput }
  ) => BatchPayloadPromise;
  upsertField: (
    args: {
      where: FieldWhereUniqueInput;
      create: FieldCreateInput;
      update: FieldUpdateInput;
    }
  ) => FieldPromise;
  deleteField: (where: FieldWhereUniqueInput) => FieldPromise;
  deleteManyFields: (where?: FieldWhereInput) => BatchPayloadPromise;
  createFieldInstance: (data: FieldInstanceCreateInput) => FieldInstancePromise;
  updateFieldInstance: (
    args: {
      data: FieldInstanceUpdateInput;
      where: FieldInstanceWhereUniqueInput;
    }
  ) => FieldInstancePromise;
  updateManyFieldInstances: (
    args: {
      data: FieldInstanceUpdateManyMutationInput;
      where?: FieldInstanceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFieldInstance: (
    args: {
      where: FieldInstanceWhereUniqueInput;
      create: FieldInstanceCreateInput;
      update: FieldInstanceUpdateInput;
    }
  ) => FieldInstancePromise;
  deleteFieldInstance: (
    where: FieldInstanceWhereUniqueInput
  ) => FieldInstancePromise;
  deleteManyFieldInstances: (
    where?: FieldInstanceWhereInput
  ) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (
    args: { data: FileUpdateInput; where: FileWhereUniqueInput }
  ) => FilePromise;
  updateManyFiles: (
    args: { data: FileUpdateManyMutationInput; where?: FileWhereInput }
  ) => BatchPayloadPromise;
  upsertFile: (
    args: {
      where: FileWhereUniqueInput;
      create: FileCreateInput;
      update: FileUpdateInput;
    }
  ) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createInvite: (data: InviteCreateInput) => InvitePromise;
  updateInvite: (
    args: { data: InviteUpdateInput; where: InviteWhereUniqueInput }
  ) => InvitePromise;
  updateManyInvites: (
    args: { data: InviteUpdateManyMutationInput; where?: InviteWhereInput }
  ) => BatchPayloadPromise;
  upsertInvite: (
    args: {
      where: InviteWhereUniqueInput;
      create: InviteCreateInput;
      update: InviteUpdateInput;
    }
  ) => InvitePromise;
  deleteInvite: (where: InviteWhereUniqueInput) => InvitePromise;
  deleteManyInvites: (where?: InviteWhereInput) => BatchPayloadPromise;
  createJob: (data: JobCreateInput) => JobPromise;
  updateJob: (
    args: { data: JobUpdateInput; where: JobWhereUniqueInput }
  ) => JobPromise;
  updateManyJobs: (
    args: { data: JobUpdateManyMutationInput; where?: JobWhereInput }
  ) => BatchPayloadPromise;
  upsertJob: (
    args: {
      where: JobWhereUniqueInput;
      create: JobCreateInput;
      update: JobUpdateInput;
    }
  ) => JobPromise;
  deleteJob: (where: JobWhereUniqueInput) => JobPromise;
  deleteManyJobs: (where?: JobWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput }
  ) => LocationPromise;
  updateManyLocations: (
    args: { data: LocationUpdateManyMutationInput; where?: LocationWhereInput }
  ) => BatchPayloadPromise;
  upsertLocation: (
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    }
  ) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createSource: (data: SourceCreateInput) => SourcePromise;
  updateSource: (
    args: { data: SourceUpdateInput; where: SourceWhereUniqueInput }
  ) => SourcePromise;
  updateManySources: (
    args: { data: SourceUpdateManyMutationInput; where?: SourceWhereInput }
  ) => BatchPayloadPromise;
  upsertSource: (
    args: {
      where: SourceWhereUniqueInput;
      create: SourceCreateInput;
      update: SourceUpdateInput;
    }
  ) => SourcePromise;
  deleteSource: (where: SourceWhereUniqueInput) => SourcePromise;
  deleteManySources: (where?: SourceWhereInput) => BatchPayloadPromise;
  createStage: (data: StageCreateInput) => StagePromise;
  updateStage: (
    args: { data: StageUpdateInput; where: StageWhereUniqueInput }
  ) => StagePromise;
  updateManyStages: (
    args: { data: StageUpdateManyMutationInput; where?: StageWhereInput }
  ) => BatchPayloadPromise;
  upsertStage: (
    args: {
      where: StageWhereUniqueInput;
      create: StageCreateInput;
      update: StageUpdateInput;
    }
  ) => StagePromise;
  deleteStage: (where: StageWhereUniqueInput) => StagePromise;
  deleteManyStages: (where?: StageWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTask: (data: TaskCreateInput) => TaskPromise;
  updateTask: (
    args: { data: TaskUpdateInput; where: TaskWhereUniqueInput }
  ) => TaskPromise;
  updateManyTasks: (
    args: { data: TaskUpdateManyMutationInput; where?: TaskWhereInput }
  ) => BatchPayloadPromise;
  upsertTask: (
    args: {
      where: TaskWhereUniqueInput;
      create: TaskCreateInput;
      update: TaskUpdateInput;
    }
  ) => TaskPromise;
  deleteTask: (where: TaskWhereUniqueInput) => TaskPromise;
  deleteManyTasks: (where?: TaskWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWorkflow: (data: WorkflowCreateInput) => WorkflowPromise;
  updateWorkflow: (
    args: { data: WorkflowUpdateInput; where: WorkflowWhereUniqueInput }
  ) => WorkflowPromise;
  updateManyWorkflows: (
    args: { data: WorkflowUpdateManyMutationInput; where?: WorkflowWhereInput }
  ) => BatchPayloadPromise;
  upsertWorkflow: (
    args: {
      where: WorkflowWhereUniqueInput;
      create: WorkflowCreateInput;
      update: WorkflowUpdateInput;
    }
  ) => WorkflowPromise;
  deleteWorkflow: (where: WorkflowWhereUniqueInput) => WorkflowPromise;
  deleteManyWorkflows: (where?: WorkflowWhereInput) => BatchPayloadPromise;
  createWorkspace: (data: WorkspaceCreateInput) => WorkspacePromise;
  updateWorkspace: (
    args: { data: WorkspaceUpdateInput; where: WorkspaceWhereUniqueInput }
  ) => WorkspacePromise;
  updateManyWorkspaces: (
    args: {
      data: WorkspaceUpdateManyMutationInput;
      where?: WorkspaceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertWorkspace: (
    args: {
      where: WorkspaceWhereUniqueInput;
      create: WorkspaceCreateInput;
      update: WorkspaceUpdateInput;
    }
  ) => WorkspacePromise;
  deleteWorkspace: (where: WorkspaceWhereUniqueInput) => WorkspacePromise;
  deleteManyWorkspaces: (where?: WorkspaceWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  application: (
    where?: ApplicationSubscriptionWhereInput
  ) => ApplicationSubscriptionPayloadSubscription;
  candidate: (
    where?: CandidateSubscriptionWhereInput
  ) => CandidateSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  disqualification: (
    where?: DisqualificationSubscriptionWhereInput
  ) => DisqualificationSubscriptionPayloadSubscription;
  disqualificationInstance: (
    where?: DisqualificationInstanceSubscriptionWhereInput
  ) => DisqualificationInstanceSubscriptionPayloadSubscription;
  field: (
    where?: FieldSubscriptionWhereInput
  ) => FieldSubscriptionPayloadSubscription;
  fieldInstance: (
    where?: FieldInstanceSubscriptionWhereInput
  ) => FieldInstanceSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  invite: (
    where?: InviteSubscriptionWhereInput
  ) => InviteSubscriptionPayloadSubscription;
  job: (
    where?: JobSubscriptionWhereInput
  ) => JobSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  source: (
    where?: SourceSubscriptionWhereInput
  ) => SourceSubscriptionPayloadSubscription;
  stage: (
    where?: StageSubscriptionWhereInput
  ) => StageSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  task: (
    where?: TaskSubscriptionWhereInput
  ) => TaskSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  workflow: (
    where?: WorkflowSubscriptionWhereInput
  ) => WorkflowSubscriptionPayloadSubscription;
  workspace: (
    where?: WorkspaceSubscriptionWhereInput
  ) => WorkspaceSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ApplicationType = "QUALIFIED" | "DISQUALIFIED";

export type FieldType =
  | "INT"
  | "FLOAT"
  | "TEXT"
  | "PARAGRAPH"
  | "BOOLEAN"
  | "DATETIME";

export type StageType = "NEW" | "PIPELINE" | "FINAL";

export type JobType = "DRAFT" | "PUBLISHED" | "ARCHIVED";

export type TaskOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "dueAt_ASC"
  | "dueAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "settings_ASC"
  | "settings_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "username_ASC"
  | "username_DESC"
  | "lastLogin_ASC"
  | "lastLogin_DESC"
  | "deletedAt_ASC"
  | "deletedAt_DESC"
  | "position_ASC"
  | "position_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "size_ASC"
  | "size_DESC"
  | "type_ASC"
  | "type_DESC"
  | "name_ASC"
  | "name_DESC"
  | "url_ASC"
  | "url_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "label_ASC"
  | "label_DESC"
  | "description_ASC"
  | "description_DESC";

export type SourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "label_ASC"
  | "label_DESC"
  | "description_ASC"
  | "description_DESC";

export type FieldInstanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "value_ASC"
  | "value_DESC";

export type ApplicationOrderByInput =
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "id_ASC"
  | "id_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type JobOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "department_ASC"
  | "department_DESC"
  | "name_ASC"
  | "name_DESC"
  | "excerpt_ASC"
  | "excerpt_DESC"
  | "companyDescription_ASC"
  | "companyDescription_DESC"
  | "description_ASC"
  | "description_DESC"
  | "requirements_ASC"
  | "requirements_DESC";

export type CandidateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "company_ASC"
  | "company_DESC"
  | "headline_ASC"
  | "headline_DESC"
  | "position_ASC"
  | "position_DESC";

export type WorkflowOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type StageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "type_ASC"
  | "type_DESC";

export type DisqualificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type FieldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "type_ASC"
  | "type_DESC"
  | "label_ASC"
  | "label_DESC"
  | "description_ASC"
  | "description_DESC";

export type InviteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "expireAt_ASC"
  | "expireAt_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "country_ASC"
  | "country_DESC"
  | "region_ASC"
  | "region_DESC"
  | "city_ASC"
  | "city_DESC"
  | "zip_ASC"
  | "zip_DESC";

export type DisqualificationInstanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "content_ASC"
  | "content_DESC";

export type WorkspaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "settings_ASC"
  | "settings_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ApplicationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TaskWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  owners_every?: UserWhereInput;
  owners_some?: UserWhereInput;
  owners_none?: UserWhereInput;
  candidate?: CandidateWhereInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  dueAt?: DateTimeInput;
  dueAt_not?: DateTimeInput;
  dueAt_in?: DateTimeInput[] | DateTimeInput;
  dueAt_not_in?: DateTimeInput[] | DateTimeInput;
  dueAt_lt?: DateTimeInput;
  dueAt_lte?: DateTimeInput;
  dueAt_gt?: DateTimeInput;
  dueAt_gte?: DateTimeInput;
  AND?: TaskWhereInput[] | TaskWhereInput;
  OR?: TaskWhereInput[] | TaskWhereInput;
  NOT?: TaskWhereInput[] | TaskWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  tasks_every?: TaskWhereInput;
  tasks_some?: TaskWhereInput;
  tasks_none?: TaskWhereInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  lastLogin?: DateTimeInput;
  lastLogin_not?: DateTimeInput;
  lastLogin_in?: DateTimeInput[] | DateTimeInput;
  lastLogin_not_in?: DateTimeInput[] | DateTimeInput;
  lastLogin_lt?: DateTimeInput;
  lastLogin_lte?: DateTimeInput;
  lastLogin_gt?: DateTimeInput;
  lastLogin_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  avatar?: FileWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export interface CandidateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  avatar?: FileWhereInput;
  company?: String;
  company_not?: String;
  company_in?: String[] | String;
  company_not_in?: String[] | String;
  company_lt?: String;
  company_lte?: String;
  company_gt?: String;
  company_gte?: String;
  company_contains?: String;
  company_not_contains?: String;
  company_starts_with?: String;
  company_not_starts_with?: String;
  company_ends_with?: String;
  company_not_ends_with?: String;
  headline?: String;
  headline_not?: String;
  headline_in?: String[] | String;
  headline_not_in?: String[] | String;
  headline_lt?: String;
  headline_lte?: String;
  headline_gt?: String;
  headline_gte?: String;
  headline_contains?: String;
  headline_not_contains?: String;
  headline_starts_with?: String;
  headline_not_starts_with?: String;
  headline_ends_with?: String;
  headline_not_ends_with?: String;
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  resumesFile_every?: FileWhereInput;
  resumesFile_some?: FileWhereInput;
  resumesFile_none?: FileWhereInput;
  coverLettersFile_every?: FileWhereInput;
  coverLettersFile_some?: FileWhereInput;
  coverLettersFile_none?: FileWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  sources_every?: SourceWhereInput;
  sources_some?: SourceWhereInput;
  sources_none?: SourceWhereInput;
  fields_every?: FieldInstanceWhereInput;
  fields_some?: FieldInstanceWhereInput;
  fields_none?: FieldInstanceWhereInput;
  tasks_every?: TaskWhereInput;
  tasks_some?: TaskWhereInput;
  tasks_none?: TaskWhereInput;
  applications_every?: ApplicationWhereInput;
  applications_some?: ApplicationWhereInput;
  applications_none?: ApplicationWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  AND?: CandidateWhereInput[] | CandidateWhereInput;
  OR?: CandidateWhereInput[] | CandidateWhereInput;
  NOT?: CandidateWhereInput[] | CandidateWhereInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface SourceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: SourceWhereInput[] | SourceWhereInput;
  OR?: SourceWhereInput[] | SourceWhereInput;
  NOT?: SourceWhereInput[] | SourceWhereInput;
}

export interface FieldInstanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  field?: FieldWhereInput;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: FieldInstanceWhereInput[] | FieldInstanceWhereInput;
  OR?: FieldInstanceWhereInput[] | FieldInstanceWhereInput;
  NOT?: FieldInstanceWhereInput[] | FieldInstanceWhereInput;
}

export interface FieldWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: FieldType;
  type_not?: FieldType;
  type_in?: FieldType[] | FieldType;
  type_not_in?: FieldType[] | FieldType;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: FieldWhereInput[] | FieldWhereInput;
  OR?: FieldWhereInput[] | FieldWhereInput;
  NOT?: FieldWhereInput[] | FieldWhereInput;
}

export interface ApplicationWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: ApplicationType;
  type_not?: ApplicationType;
  type_in?: ApplicationType[] | ApplicationType;
  type_not_in?: ApplicationType[] | ApplicationType;
  disqualification?: DisqualificationInstanceWhereInput;
  stage?: StageWhereInput;
  job?: JobWhereInput;
  candidate?: CandidateWhereInput;
  AND?: ApplicationWhereInput[] | ApplicationWhereInput;
  OR?: ApplicationWhereInput[] | ApplicationWhereInput;
  NOT?: ApplicationWhereInput[] | ApplicationWhereInput;
}

export interface DisqualificationInstanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  disqualification?: DisqualificationWhereInput;
  createdBy?: UserWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?:
    | DisqualificationInstanceWhereInput[]
    | DisqualificationInstanceWhereInput;
  OR?:
    | DisqualificationInstanceWhereInput[]
    | DisqualificationInstanceWhereInput;
  NOT?:
    | DisqualificationInstanceWhereInput[]
    | DisqualificationInstanceWhereInput;
}

export interface DisqualificationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: DisqualificationWhereInput[] | DisqualificationWhereInput;
  OR?: DisqualificationWhereInput[] | DisqualificationWhereInput;
  NOT?: DisqualificationWhereInput[] | DisqualificationWhereInput;
}

export interface StageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  type?: StageType;
  type_not?: StageType;
  type_in?: StageType[] | StageType;
  type_not_in?: StageType[] | StageType;
  AND?: StageWhereInput[] | StageWhereInput;
  OR?: StageWhereInput[] | StageWhereInput;
  NOT?: StageWhereInput[] | StageWhereInput;
}

export interface JobWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  workspace?: WorkspaceWhereInput;
  applications_every?: ApplicationWhereInput;
  applications_some?: ApplicationWhereInput;
  applications_none?: ApplicationWhereInput;
  workflow?: WorkflowWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  type?: JobType;
  type_not?: JobType;
  type_in?: JobType[] | JobType;
  type_not_in?: JobType[] | JobType;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  locations_every?: LocationWhereInput;
  locations_some?: LocationWhereInput;
  locations_none?: LocationWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  excerpt?: String;
  excerpt_not?: String;
  excerpt_in?: String[] | String;
  excerpt_not_in?: String[] | String;
  excerpt_lt?: String;
  excerpt_lte?: String;
  excerpt_gt?: String;
  excerpt_gte?: String;
  excerpt_contains?: String;
  excerpt_not_contains?: String;
  excerpt_starts_with?: String;
  excerpt_not_starts_with?: String;
  excerpt_ends_with?: String;
  excerpt_not_ends_with?: String;
  companyDescription?: String;
  companyDescription_not?: String;
  companyDescription_in?: String[] | String;
  companyDescription_not_in?: String[] | String;
  companyDescription_lt?: String;
  companyDescription_lte?: String;
  companyDescription_gt?: String;
  companyDescription_gte?: String;
  companyDescription_contains?: String;
  companyDescription_not_contains?: String;
  companyDescription_starts_with?: String;
  companyDescription_not_starts_with?: String;
  companyDescription_ends_with?: String;
  companyDescription_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  requirements?: String;
  requirements_not?: String;
  requirements_in?: String[] | String;
  requirements_not_in?: String[] | String;
  requirements_lt?: String;
  requirements_lte?: String;
  requirements_gt?: String;
  requirements_gte?: String;
  requirements_contains?: String;
  requirements_not_contains?: String;
  requirements_starts_with?: String;
  requirements_not_starts_with?: String;
  requirements_ends_with?: String;
  requirements_not_ends_with?: String;
  AND?: JobWhereInput[] | JobWhereInput;
  OR?: JobWhereInput[] | JobWhereInput;
  NOT?: JobWhereInput[] | JobWhereInput;
}

export interface WorkspaceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  jobs_every?: JobWhereInput;
  jobs_some?: JobWhereInput;
  jobs_none?: JobWhereInput;
  candidates_every?: CandidateWhereInput;
  candidates_some?: CandidateWhereInput;
  candidates_none?: CandidateWhereInput;
  workflows_every?: WorkflowWhereInput;
  workflows_some?: WorkflowWhereInput;
  workflows_none?: WorkflowWhereInput;
  invites_every?: InviteWhereInput;
  invites_some?: InviteWhereInput;
  invites_none?: InviteWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: WorkspaceWhereInput[] | WorkspaceWhereInput;
  OR?: WorkspaceWhereInput[] | WorkspaceWhereInput;
  NOT?: WorkspaceWhereInput[] | WorkspaceWhereInput;
}

export interface WorkflowWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  stages_every?: StageWhereInput;
  stages_some?: StageWhereInput;
  stages_none?: StageWhereInput;
  disqualifications_every?: DisqualificationWhereInput;
  disqualifications_some?: DisqualificationWhereInput;
  disqualifications_none?: DisqualificationWhereInput;
  fields_every?: FieldWhereInput;
  fields_some?: FieldWhereInput;
  fields_none?: FieldWhereInput;
  AND?: WorkflowWhereInput[] | WorkflowWhereInput;
  OR?: WorkflowWhereInput[] | WorkflowWhereInput;
  NOT?: WorkflowWhereInput[] | WorkflowWhereInput;
}

export interface InviteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  expireAt?: DateTimeInput;
  expireAt_not?: DateTimeInput;
  expireAt_in?: DateTimeInput[] | DateTimeInput;
  expireAt_not_in?: DateTimeInput[] | DateTimeInput;
  expireAt_lt?: DateTimeInput;
  expireAt_lte?: DateTimeInput;
  expireAt_gt?: DateTimeInput;
  expireAt_gte?: DateTimeInput;
  invitedBy?: UserWhereInput;
  AND?: InviteWhereInput[] | InviteWhereInput;
  OR?: InviteWhereInput[] | InviteWhereInput;
  NOT?: InviteWhereInput[] | InviteWhereInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  createdBy?: UserWhereInput;
  parent?: CommentWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  region?: String;
  region_not?: String;
  region_in?: String[] | String;
  region_not_in?: String[] | String;
  region_lt?: String;
  region_lte?: String;
  region_gt?: String;
  region_gte?: String;
  region_contains?: String;
  region_not_contains?: String;
  region_starts_with?: String;
  region_not_starts_with?: String;
  region_ends_with?: String;
  region_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  zip?: String;
  zip_not?: String;
  zip_in?: String[] | String;
  zip_not_in?: String[] | String;
  zip_lt?: String;
  zip_lte?: String;
  zip_gt?: String;
  zip_gte?: String;
  zip_contains?: String;
  zip_not_contains?: String;
  zip_starts_with?: String;
  zip_not_starts_with?: String;
  zip_ends_with?: String;
  zip_not_ends_with?: String;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export type CandidateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type DisqualificationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type DisqualificationInstanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FieldWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FieldInstanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export type InviteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type JobWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SourceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type StageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TaskWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export type WorkflowWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type WorkspaceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ApplicationCreateInput {
  type: ApplicationType;
  disqualification?: DisqualificationInstanceCreateOneInput;
  stage: StageCreateOneInput;
  job: JobCreateOneWithoutApplicationsInput;
  candidate: CandidateCreateOneWithoutApplicationsInput;
}

export interface DisqualificationInstanceCreateOneInput {
  create?: DisqualificationInstanceCreateInput;
  connect?: DisqualificationInstanceWhereUniqueInput;
}

export interface DisqualificationInstanceCreateInput {
  disqualification: DisqualificationCreateOneInput;
  createdBy: UserCreateOneInput;
  content?: String;
}

export interface DisqualificationCreateOneInput {
  create?: DisqualificationCreateInput;
  connect?: DisqualificationWhereUniqueInput;
}

export interface DisqualificationCreateInput {
  name: String;
  description?: String;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  settings?: Json;
  tasks?: TaskCreateManyWithoutOwnersInput;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface TaskCreateManyWithoutOwnersInput {
  create?: TaskCreateWithoutOwnersInput[] | TaskCreateWithoutOwnersInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
}

export interface TaskCreateWithoutOwnersInput {
  candidate?: CandidateCreateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface CandidateCreateOneWithoutTasksInput {
  create?: CandidateCreateWithoutTasksInput;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateCreateWithoutTasksInput {
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  sources?: SourceCreateManyInput;
  fields?: FieldInstanceCreateManyInput;
  applications?: ApplicationCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface CandidateCreateemailsInput {
  set?: String[] | String;
}

export interface CandidateCreatephonesInput {
  set?: String[] | String;
}

export interface CandidateCreatelinksInput {
  set?: String[] | String;
}

export interface FileCreateOneInput {
  create?: FileCreateInput;
  connect?: FileWhereUniqueInput;
}

export interface FileCreateInput {
  size: Int;
  type: String;
  name: String;
  url: String;
}

export interface CandidateCreateresumesStringInput {
  set?: String[] | String;
}

export interface FileCreateManyInput {
  create?: FileCreateInput[] | FileCreateInput;
  connect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
}

export interface CandidateCreatecoverLettersStringInput {
  set?: String[] | String;
}

export interface TagCreateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface TagCreateInput {
  label: String;
  description?: String;
}

export interface SourceCreateManyInput {
  create?: SourceCreateInput[] | SourceCreateInput;
  connect?: SourceWhereUniqueInput[] | SourceWhereUniqueInput;
}

export interface SourceCreateInput {
  label: String;
  description?: String;
}

export interface FieldInstanceCreateManyInput {
  create?: FieldInstanceCreateInput[] | FieldInstanceCreateInput;
  connect?: FieldInstanceWhereUniqueInput[] | FieldInstanceWhereUniqueInput;
}

export interface FieldInstanceCreateInput {
  field: FieldCreateOneInput;
  value?: String;
}

export interface FieldCreateOneInput {
  create?: FieldCreateInput;
  connect?: FieldWhereUniqueInput;
}

export interface FieldCreateInput {
  type: FieldType;
  label: String;
  description?: String;
}

export interface ApplicationCreateManyWithoutCandidateInput {
  create?:
    | ApplicationCreateWithoutCandidateInput[]
    | ApplicationCreateWithoutCandidateInput;
  connect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
}

export interface ApplicationCreateWithoutCandidateInput {
  type: ApplicationType;
  disqualification?: DisqualificationInstanceCreateOneInput;
  stage: StageCreateOneInput;
  job: JobCreateOneWithoutApplicationsInput;
}

export interface StageCreateOneInput {
  create?: StageCreateInput;
  connect?: StageWhereUniqueInput;
}

export interface StageCreateInput {
  name: String;
  description?: String;
  type: StageType;
}

export interface JobCreateOneWithoutApplicationsInput {
  create?: JobCreateWithoutApplicationsInput;
  connect?: JobWhereUniqueInput;
}

export interface JobCreateWithoutApplicationsInput {
  workspace: WorkspaceCreateOneWithoutJobsInput;
  workflow: WorkflowCreateOneInput;
  comments?: CommentCreateManyInput;
  type: JobType;
  department?: String;
  locations?: LocationCreateManyInput;
  name: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface WorkspaceCreateOneWithoutJobsInput {
  create?: WorkspaceCreateWithoutJobsInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceCreateWithoutJobsInput {
  users?: UserCreateManyInput;
  candidates?: CandidateCreateManyInput;
  settings?: Json;
  workflows?: WorkflowCreateManyInput;
  invites?: InviteCreateManyInput;
  name: String;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface CandidateCreateManyInput {
  create?: CandidateCreateInput[] | CandidateCreateInput;
  connect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
}

export interface CandidateCreateInput {
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  sources?: SourceCreateManyInput;
  fields?: FieldInstanceCreateManyInput;
  tasks?: TaskCreateManyWithoutCandidateInput;
  applications?: ApplicationCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface TaskCreateManyWithoutCandidateInput {
  create?: TaskCreateWithoutCandidateInput[] | TaskCreateWithoutCandidateInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
}

export interface TaskCreateWithoutCandidateInput {
  owners?: UserCreateManyWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserCreateManyWithoutTasksInput {
  create?: UserCreateWithoutTasksInput[] | UserCreateWithoutTasksInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutTasksInput {
  settings?: Json;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileCreateOneInput;
}

export interface CommentCreateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateInput {
  createdBy: UserCreateOneInput;
  parent?: CommentCreateOneInput;
  content: String;
}

export interface CommentCreateOneInput {
  create?: CommentCreateInput;
  connect?: CommentWhereUniqueInput;
}

export interface WorkflowCreateManyInput {
  create?: WorkflowCreateInput[] | WorkflowCreateInput;
  connect?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
}

export interface WorkflowCreateInput {
  name: String;
  description?: String;
  stages?: StageCreateManyInput;
  disqualifications?: DisqualificationCreateManyInput;
  fields?: FieldCreateManyInput;
}

export interface StageCreateManyInput {
  create?: StageCreateInput[] | StageCreateInput;
  connect?: StageWhereUniqueInput[] | StageWhereUniqueInput;
}

export interface DisqualificationCreateManyInput {
  create?: DisqualificationCreateInput[] | DisqualificationCreateInput;
  connect?:
    | DisqualificationWhereUniqueInput[]
    | DisqualificationWhereUniqueInput;
}

export interface FieldCreateManyInput {
  create?: FieldCreateInput[] | FieldCreateInput;
  connect?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
}

export interface InviteCreateManyInput {
  create?: InviteCreateInput[] | InviteCreateInput;
  connect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
}

export interface InviteCreateInput {
  email: String;
  expireAt: DateTimeInput;
  invitedBy: UserCreateOneInput;
}

export interface WorkflowCreateOneInput {
  create?: WorkflowCreateInput;
  connect?: WorkflowWhereUniqueInput;
}

export interface LocationCreateManyInput {
  create?: LocationCreateInput[] | LocationCreateInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
}

export interface LocationCreateInput {
  country: String;
  region?: String;
  city: String;
  zip?: String;
}

export interface CandidateCreateOneWithoutApplicationsInput {
  create?: CandidateCreateWithoutApplicationsInput;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateCreateWithoutApplicationsInput {
  firstName: String;
  lastName: String;
  emails?: CandidateCreateemailsInput;
  phones?: CandidateCreatephonesInput;
  links?: CandidateCreatelinksInput;
  avatar?: FileCreateOneInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateCreateresumesStringInput;
  resumesFile?: FileCreateManyInput;
  coverLettersString?: CandidateCreatecoverLettersStringInput;
  coverLettersFile?: FileCreateManyInput;
  tags?: TagCreateManyInput;
  sources?: SourceCreateManyInput;
  fields?: FieldInstanceCreateManyInput;
  tasks?: TaskCreateManyWithoutCandidateInput;
  comments?: CommentCreateManyInput;
}

export interface ApplicationUpdateInput {
  type?: ApplicationType;
  disqualification?: DisqualificationInstanceUpdateOneInput;
  stage?: StageUpdateOneRequiredInput;
  job?: JobUpdateOneRequiredWithoutApplicationsInput;
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput;
}

export interface DisqualificationInstanceUpdateOneInput {
  create?: DisqualificationInstanceCreateInput;
  update?: DisqualificationInstanceUpdateDataInput;
  upsert?: DisqualificationInstanceUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DisqualificationInstanceWhereUniqueInput;
}

export interface DisqualificationInstanceUpdateDataInput {
  disqualification?: DisqualificationUpdateOneRequiredInput;
  createdBy?: UserUpdateOneRequiredInput;
  content?: String;
}

export interface DisqualificationUpdateOneRequiredInput {
  create?: DisqualificationCreateInput;
  update?: DisqualificationUpdateDataInput;
  upsert?: DisqualificationUpsertNestedInput;
  connect?: DisqualificationWhereUniqueInput;
}

export interface DisqualificationUpdateDataInput {
  name?: String;
  description?: String;
}

export interface DisqualificationUpsertNestedInput {
  update: DisqualificationUpdateDataInput;
  create: DisqualificationCreateInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  settings?: Json;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface TaskUpdateManyWithoutOwnersInput {
  create?: TaskCreateWithoutOwnersInput[] | TaskCreateWithoutOwnersInput;
  delete?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  set?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  disconnect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  update?:
    | TaskUpdateWithWhereUniqueWithoutOwnersInput[]
    | TaskUpdateWithWhereUniqueWithoutOwnersInput;
  upsert?:
    | TaskUpsertWithWhereUniqueWithoutOwnersInput[]
    | TaskUpsertWithWhereUniqueWithoutOwnersInput;
  deleteMany?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  updateMany?:
    | TaskUpdateManyWithWhereNestedInput[]
    | TaskUpdateManyWithWhereNestedInput;
}

export interface TaskUpdateWithWhereUniqueWithoutOwnersInput {
  where: TaskWhereUniqueInput;
  data: TaskUpdateWithoutOwnersDataInput;
}

export interface TaskUpdateWithoutOwnersDataInput {
  candidate?: CandidateUpdateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface CandidateUpdateOneWithoutTasksInput {
  create?: CandidateCreateWithoutTasksInput;
  update?: CandidateUpdateWithoutTasksDataInput;
  upsert?: CandidateUpsertWithoutTasksInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateUpdateWithoutTasksDataInput {
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  sources?: SourceUpdateManyInput;
  fields?: FieldInstanceUpdateManyInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface CandidateUpdateemailsInput {
  set?: String[] | String;
}

export interface CandidateUpdatephonesInput {
  set?: String[] | String;
}

export interface CandidateUpdatelinksInput {
  set?: String[] | String;
}

export interface FileUpdateOneInput {
  create?: FileCreateInput;
  update?: FileUpdateDataInput;
  upsert?: FileUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FileWhereUniqueInput;
}

export interface FileUpdateDataInput {
  size?: Int;
  type?: String;
  name?: String;
  url?: String;
}

export interface FileUpsertNestedInput {
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface CandidateUpdateresumesStringInput {
  set?: String[] | String;
}

export interface FileUpdateManyInput {
  create?: FileCreateInput[] | FileCreateInput;
  update?:
    | FileUpdateWithWhereUniqueNestedInput[]
    | FileUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FileUpsertWithWhereUniqueNestedInput[]
    | FileUpsertWithWhereUniqueNestedInput;
  delete?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  connect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  set?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  disconnect?: FileWhereUniqueInput[] | FileWhereUniqueInput;
  deleteMany?: FileScalarWhereInput[] | FileScalarWhereInput;
  updateMany?:
    | FileUpdateManyWithWhereNestedInput[]
    | FileUpdateManyWithWhereNestedInput;
}

export interface FileUpdateWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  data: FileUpdateDataInput;
}

export interface FileUpsertWithWhereUniqueNestedInput {
  where: FileWhereUniqueInput;
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface FileScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  size?: Int;
  size_not?: Int;
  size_in?: Int[] | Int;
  size_not_in?: Int[] | Int;
  size_lt?: Int;
  size_lte?: Int;
  size_gt?: Int;
  size_gte?: Int;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: FileScalarWhereInput[] | FileScalarWhereInput;
  OR?: FileScalarWhereInput[] | FileScalarWhereInput;
  NOT?: FileScalarWhereInput[] | FileScalarWhereInput;
}

export interface FileUpdateManyWithWhereNestedInput {
  where: FileScalarWhereInput;
  data: FileUpdateManyDataInput;
}

export interface FileUpdateManyDataInput {
  size?: Int;
  type?: String;
  name?: String;
  url?: String;
}

export interface CandidateUpdatecoverLettersStringInput {
  set?: String[] | String;
}

export interface TagUpdateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  update?:
    | TagUpdateWithWhereUniqueNestedInput[]
    | TagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TagUpsertWithWhereUniqueNestedInput[]
    | TagUpsertWithWhereUniqueNestedInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  set?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface TagUpdateDataInput {
  label?: String;
  description?: String;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  label?: String;
  description?: String;
}

export interface SourceUpdateManyInput {
  create?: SourceCreateInput[] | SourceCreateInput;
  update?:
    | SourceUpdateWithWhereUniqueNestedInput[]
    | SourceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SourceUpsertWithWhereUniqueNestedInput[]
    | SourceUpsertWithWhereUniqueNestedInput;
  delete?: SourceWhereUniqueInput[] | SourceWhereUniqueInput;
  connect?: SourceWhereUniqueInput[] | SourceWhereUniqueInput;
  set?: SourceWhereUniqueInput[] | SourceWhereUniqueInput;
  disconnect?: SourceWhereUniqueInput[] | SourceWhereUniqueInput;
  deleteMany?: SourceScalarWhereInput[] | SourceScalarWhereInput;
  updateMany?:
    | SourceUpdateManyWithWhereNestedInput[]
    | SourceUpdateManyWithWhereNestedInput;
}

export interface SourceUpdateWithWhereUniqueNestedInput {
  where: SourceWhereUniqueInput;
  data: SourceUpdateDataInput;
}

export interface SourceUpdateDataInput {
  label?: String;
  description?: String;
}

export interface SourceUpsertWithWhereUniqueNestedInput {
  where: SourceWhereUniqueInput;
  update: SourceUpdateDataInput;
  create: SourceCreateInput;
}

export interface SourceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: SourceScalarWhereInput[] | SourceScalarWhereInput;
  OR?: SourceScalarWhereInput[] | SourceScalarWhereInput;
  NOT?: SourceScalarWhereInput[] | SourceScalarWhereInput;
}

export interface SourceUpdateManyWithWhereNestedInput {
  where: SourceScalarWhereInput;
  data: SourceUpdateManyDataInput;
}

export interface SourceUpdateManyDataInput {
  label?: String;
  description?: String;
}

export interface FieldInstanceUpdateManyInput {
  create?: FieldInstanceCreateInput[] | FieldInstanceCreateInput;
  update?:
    | FieldInstanceUpdateWithWhereUniqueNestedInput[]
    | FieldInstanceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FieldInstanceUpsertWithWhereUniqueNestedInput[]
    | FieldInstanceUpsertWithWhereUniqueNestedInput;
  delete?: FieldInstanceWhereUniqueInput[] | FieldInstanceWhereUniqueInput;
  connect?: FieldInstanceWhereUniqueInput[] | FieldInstanceWhereUniqueInput;
  set?: FieldInstanceWhereUniqueInput[] | FieldInstanceWhereUniqueInput;
  disconnect?: FieldInstanceWhereUniqueInput[] | FieldInstanceWhereUniqueInput;
  deleteMany?: FieldInstanceScalarWhereInput[] | FieldInstanceScalarWhereInput;
  updateMany?:
    | FieldInstanceUpdateManyWithWhereNestedInput[]
    | FieldInstanceUpdateManyWithWhereNestedInput;
}

export interface FieldInstanceUpdateWithWhereUniqueNestedInput {
  where: FieldInstanceWhereUniqueInput;
  data: FieldInstanceUpdateDataInput;
}

export interface FieldInstanceUpdateDataInput {
  field?: FieldUpdateOneRequiredInput;
  value?: String;
}

export interface FieldUpdateOneRequiredInput {
  create?: FieldCreateInput;
  update?: FieldUpdateDataInput;
  upsert?: FieldUpsertNestedInput;
  connect?: FieldWhereUniqueInput;
}

export interface FieldUpdateDataInput {
  type?: FieldType;
  label?: String;
  description?: String;
}

export interface FieldUpsertNestedInput {
  update: FieldUpdateDataInput;
  create: FieldCreateInput;
}

export interface FieldInstanceUpsertWithWhereUniqueNestedInput {
  where: FieldInstanceWhereUniqueInput;
  update: FieldInstanceUpdateDataInput;
  create: FieldInstanceCreateInput;
}

export interface FieldInstanceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  AND?: FieldInstanceScalarWhereInput[] | FieldInstanceScalarWhereInput;
  OR?: FieldInstanceScalarWhereInput[] | FieldInstanceScalarWhereInput;
  NOT?: FieldInstanceScalarWhereInput[] | FieldInstanceScalarWhereInput;
}

export interface FieldInstanceUpdateManyWithWhereNestedInput {
  where: FieldInstanceScalarWhereInput;
  data: FieldInstanceUpdateManyDataInput;
}

export interface FieldInstanceUpdateManyDataInput {
  value?: String;
}

export interface ApplicationUpdateManyWithoutCandidateInput {
  create?:
    | ApplicationCreateWithoutCandidateInput[]
    | ApplicationCreateWithoutCandidateInput;
  delete?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  connect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  set?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  disconnect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  update?:
    | ApplicationUpdateWithWhereUniqueWithoutCandidateInput[]
    | ApplicationUpdateWithWhereUniqueWithoutCandidateInput;
  upsert?:
    | ApplicationUpsertWithWhereUniqueWithoutCandidateInput[]
    | ApplicationUpsertWithWhereUniqueWithoutCandidateInput;
  deleteMany?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
  updateMany?:
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput;
}

export interface ApplicationUpdateWithWhereUniqueWithoutCandidateInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutCandidateDataInput;
}

export interface ApplicationUpdateWithoutCandidateDataInput {
  type?: ApplicationType;
  disqualification?: DisqualificationInstanceUpdateOneInput;
  stage?: StageUpdateOneRequiredInput;
  job?: JobUpdateOneRequiredWithoutApplicationsInput;
}

export interface StageUpdateOneRequiredInput {
  create?: StageCreateInput;
  update?: StageUpdateDataInput;
  upsert?: StageUpsertNestedInput;
  connect?: StageWhereUniqueInput;
}

export interface StageUpdateDataInput {
  name?: String;
  description?: String;
  type?: StageType;
}

export interface StageUpsertNestedInput {
  update: StageUpdateDataInput;
  create: StageCreateInput;
}

export interface JobUpdateOneRequiredWithoutApplicationsInput {
  create?: JobCreateWithoutApplicationsInput;
  update?: JobUpdateWithoutApplicationsDataInput;
  upsert?: JobUpsertWithoutApplicationsInput;
  connect?: JobWhereUniqueInput;
}

export interface JobUpdateWithoutApplicationsDataInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutJobsInput;
  workflow?: WorkflowUpdateOneRequiredInput;
  comments?: CommentUpdateManyInput;
  type?: JobType;
  department?: String;
  locations?: LocationUpdateManyInput;
  name?: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface WorkspaceUpdateOneRequiredWithoutJobsInput {
  create?: WorkspaceCreateWithoutJobsInput;
  update?: WorkspaceUpdateWithoutJobsDataInput;
  upsert?: WorkspaceUpsertWithoutJobsInput;
  connect?: WorkspaceWhereUniqueInput;
}

export interface WorkspaceUpdateWithoutJobsDataInput {
  users?: UserUpdateManyInput;
  candidates?: CandidateUpdateManyInput;
  settings?: Json;
  workflows?: WorkflowUpdateManyInput;
  invites?: InviteUpdateManyInput;
  name?: String;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  lastLogin?: DateTimeInput;
  lastLogin_not?: DateTimeInput;
  lastLogin_in?: DateTimeInput[] | DateTimeInput;
  lastLogin_not_in?: DateTimeInput[] | DateTimeInput;
  lastLogin_lt?: DateTimeInput;
  lastLogin_lte?: DateTimeInput;
  lastLogin_gt?: DateTimeInput;
  lastLogin_gte?: DateTimeInput;
  deletedAt?: DateTimeInput;
  deletedAt_not?: DateTimeInput;
  deletedAt_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_not_in?: DateTimeInput[] | DateTimeInput;
  deletedAt_lt?: DateTimeInput;
  deletedAt_lte?: DateTimeInput;
  deletedAt_gt?: DateTimeInput;
  deletedAt_gte?: DateTimeInput;
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  settings?: Json;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
}

export interface CandidateUpdateManyInput {
  create?: CandidateCreateInput[] | CandidateCreateInput;
  update?:
    | CandidateUpdateWithWhereUniqueNestedInput[]
    | CandidateUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CandidateUpsertWithWhereUniqueNestedInput[]
    | CandidateUpsertWithWhereUniqueNestedInput;
  delete?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  connect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  set?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  disconnect?: CandidateWhereUniqueInput[] | CandidateWhereUniqueInput;
  deleteMany?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
  updateMany?:
    | CandidateUpdateManyWithWhereNestedInput[]
    | CandidateUpdateManyWithWhereNestedInput;
}

export interface CandidateUpdateWithWhereUniqueNestedInput {
  where: CandidateWhereUniqueInput;
  data: CandidateUpdateDataInput;
}

export interface CandidateUpdateDataInput {
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  sources?: SourceUpdateManyInput;
  fields?: FieldInstanceUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface TaskUpdateManyWithoutCandidateInput {
  create?: TaskCreateWithoutCandidateInput[] | TaskCreateWithoutCandidateInput;
  delete?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  connect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  set?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  disconnect?: TaskWhereUniqueInput[] | TaskWhereUniqueInput;
  update?:
    | TaskUpdateWithWhereUniqueWithoutCandidateInput[]
    | TaskUpdateWithWhereUniqueWithoutCandidateInput;
  upsert?:
    | TaskUpsertWithWhereUniqueWithoutCandidateInput[]
    | TaskUpsertWithWhereUniqueWithoutCandidateInput;
  deleteMany?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  updateMany?:
    | TaskUpdateManyWithWhereNestedInput[]
    | TaskUpdateManyWithWhereNestedInput;
}

export interface TaskUpdateWithWhereUniqueWithoutCandidateInput {
  where: TaskWhereUniqueInput;
  data: TaskUpdateWithoutCandidateDataInput;
}

export interface TaskUpdateWithoutCandidateDataInput {
  owners?: UserUpdateManyWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserUpdateManyWithoutTasksInput {
  create?: UserCreateWithoutTasksInput[] | UserCreateWithoutTasksInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTasksInput[]
    | UserUpdateWithWhereUniqueWithoutTasksInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTasksInput[]
    | UserUpsertWithWhereUniqueWithoutTasksInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutTasksInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTasksDataInput;
}

export interface UserUpdateWithoutTasksDataInput {
  settings?: Json;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface UserUpsertWithWhereUniqueWithoutTasksInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTasksDataInput;
  create: UserCreateWithoutTasksInput;
}

export interface TaskUpsertWithWhereUniqueWithoutCandidateInput {
  where: TaskWhereUniqueInput;
  update: TaskUpdateWithoutCandidateDataInput;
  create: TaskCreateWithoutCandidateInput;
}

export interface TaskScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  dueAt?: DateTimeInput;
  dueAt_not?: DateTimeInput;
  dueAt_in?: DateTimeInput[] | DateTimeInput;
  dueAt_not_in?: DateTimeInput[] | DateTimeInput;
  dueAt_lt?: DateTimeInput;
  dueAt_lte?: DateTimeInput;
  dueAt_gt?: DateTimeInput;
  dueAt_gte?: DateTimeInput;
  AND?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  OR?: TaskScalarWhereInput[] | TaskScalarWhereInput;
  NOT?: TaskScalarWhereInput[] | TaskScalarWhereInput;
}

export interface TaskUpdateManyWithWhereNestedInput {
  where: TaskScalarWhereInput;
  data: TaskUpdateManyDataInput;
}

export interface TaskUpdateManyDataInput {
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface CommentUpdateManyInput {
  create?: CommentCreateInput[] | CommentCreateInput;
  update?:
    | CommentUpdateWithWhereUniqueNestedInput[]
    | CommentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CommentUpsertWithWhereUniqueNestedInput[]
    | CommentUpsertWithWhereUniqueNestedInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateDataInput;
}

export interface CommentUpdateDataInput {
  createdBy?: UserUpdateOneRequiredInput;
  parent?: CommentUpdateOneInput;
  content?: String;
}

export interface CommentUpdateOneInput {
  create?: CommentCreateInput;
  update?: CommentUpdateDataInput;
  upsert?: CommentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CommentWhereUniqueInput;
}

export interface CommentUpsertNestedInput {
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface CommentUpsertWithWhereUniqueNestedInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  content?: String;
}

export interface CandidateUpsertWithWhereUniqueNestedInput {
  where: CandidateWhereUniqueInput;
  update: CandidateUpdateDataInput;
  create: CandidateCreateInput;
}

export interface CandidateScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  company?: String;
  company_not?: String;
  company_in?: String[] | String;
  company_not_in?: String[] | String;
  company_lt?: String;
  company_lte?: String;
  company_gt?: String;
  company_gte?: String;
  company_contains?: String;
  company_not_contains?: String;
  company_starts_with?: String;
  company_not_starts_with?: String;
  company_ends_with?: String;
  company_not_ends_with?: String;
  headline?: String;
  headline_not?: String;
  headline_in?: String[] | String;
  headline_not_in?: String[] | String;
  headline_lt?: String;
  headline_lte?: String;
  headline_gt?: String;
  headline_gte?: String;
  headline_contains?: String;
  headline_not_contains?: String;
  headline_starts_with?: String;
  headline_not_starts_with?: String;
  headline_ends_with?: String;
  headline_not_ends_with?: String;
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  AND?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
  OR?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
  NOT?: CandidateScalarWhereInput[] | CandidateScalarWhereInput;
}

export interface CandidateUpdateManyWithWhereNestedInput {
  where: CandidateScalarWhereInput;
  data: CandidateUpdateManyDataInput;
}

export interface CandidateUpdateManyDataInput {
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
}

export interface WorkflowUpdateManyInput {
  create?: WorkflowCreateInput[] | WorkflowCreateInput;
  update?:
    | WorkflowUpdateWithWhereUniqueNestedInput[]
    | WorkflowUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WorkflowUpsertWithWhereUniqueNestedInput[]
    | WorkflowUpsertWithWhereUniqueNestedInput;
  delete?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
  connect?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
  set?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
  disconnect?: WorkflowWhereUniqueInput[] | WorkflowWhereUniqueInput;
  deleteMany?: WorkflowScalarWhereInput[] | WorkflowScalarWhereInput;
  updateMany?:
    | WorkflowUpdateManyWithWhereNestedInput[]
    | WorkflowUpdateManyWithWhereNestedInput;
}

export interface WorkflowUpdateWithWhereUniqueNestedInput {
  where: WorkflowWhereUniqueInput;
  data: WorkflowUpdateDataInput;
}

export interface WorkflowUpdateDataInput {
  name?: String;
  description?: String;
  stages?: StageUpdateManyInput;
  disqualifications?: DisqualificationUpdateManyInput;
  fields?: FieldUpdateManyInput;
}

export interface StageUpdateManyInput {
  create?: StageCreateInput[] | StageCreateInput;
  update?:
    | StageUpdateWithWhereUniqueNestedInput[]
    | StageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StageUpsertWithWhereUniqueNestedInput[]
    | StageUpsertWithWhereUniqueNestedInput;
  delete?: StageWhereUniqueInput[] | StageWhereUniqueInput;
  connect?: StageWhereUniqueInput[] | StageWhereUniqueInput;
  set?: StageWhereUniqueInput[] | StageWhereUniqueInput;
  disconnect?: StageWhereUniqueInput[] | StageWhereUniqueInput;
  deleteMany?: StageScalarWhereInput[] | StageScalarWhereInput;
  updateMany?:
    | StageUpdateManyWithWhereNestedInput[]
    | StageUpdateManyWithWhereNestedInput;
}

export interface StageUpdateWithWhereUniqueNestedInput {
  where: StageWhereUniqueInput;
  data: StageUpdateDataInput;
}

export interface StageUpsertWithWhereUniqueNestedInput {
  where: StageWhereUniqueInput;
  update: StageUpdateDataInput;
  create: StageCreateInput;
}

export interface StageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  type?: StageType;
  type_not?: StageType;
  type_in?: StageType[] | StageType;
  type_not_in?: StageType[] | StageType;
  AND?: StageScalarWhereInput[] | StageScalarWhereInput;
  OR?: StageScalarWhereInput[] | StageScalarWhereInput;
  NOT?: StageScalarWhereInput[] | StageScalarWhereInput;
}

export interface StageUpdateManyWithWhereNestedInput {
  where: StageScalarWhereInput;
  data: StageUpdateManyDataInput;
}

export interface StageUpdateManyDataInput {
  name?: String;
  description?: String;
  type?: StageType;
}

export interface DisqualificationUpdateManyInput {
  create?: DisqualificationCreateInput[] | DisqualificationCreateInput;
  update?:
    | DisqualificationUpdateWithWhereUniqueNestedInput[]
    | DisqualificationUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DisqualificationUpsertWithWhereUniqueNestedInput[]
    | DisqualificationUpsertWithWhereUniqueNestedInput;
  delete?:
    | DisqualificationWhereUniqueInput[]
    | DisqualificationWhereUniqueInput;
  connect?:
    | DisqualificationWhereUniqueInput[]
    | DisqualificationWhereUniqueInput;
  set?: DisqualificationWhereUniqueInput[] | DisqualificationWhereUniqueInput;
  disconnect?:
    | DisqualificationWhereUniqueInput[]
    | DisqualificationWhereUniqueInput;
  deleteMany?:
    | DisqualificationScalarWhereInput[]
    | DisqualificationScalarWhereInput;
  updateMany?:
    | DisqualificationUpdateManyWithWhereNestedInput[]
    | DisqualificationUpdateManyWithWhereNestedInput;
}

export interface DisqualificationUpdateWithWhereUniqueNestedInput {
  where: DisqualificationWhereUniqueInput;
  data: DisqualificationUpdateDataInput;
}

export interface DisqualificationUpsertWithWhereUniqueNestedInput {
  where: DisqualificationWhereUniqueInput;
  update: DisqualificationUpdateDataInput;
  create: DisqualificationCreateInput;
}

export interface DisqualificationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: DisqualificationScalarWhereInput[] | DisqualificationScalarWhereInput;
  OR?: DisqualificationScalarWhereInput[] | DisqualificationScalarWhereInput;
  NOT?: DisqualificationScalarWhereInput[] | DisqualificationScalarWhereInput;
}

export interface DisqualificationUpdateManyWithWhereNestedInput {
  where: DisqualificationScalarWhereInput;
  data: DisqualificationUpdateManyDataInput;
}

export interface DisqualificationUpdateManyDataInput {
  name?: String;
  description?: String;
}

export interface FieldUpdateManyInput {
  create?: FieldCreateInput[] | FieldCreateInput;
  update?:
    | FieldUpdateWithWhereUniqueNestedInput[]
    | FieldUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FieldUpsertWithWhereUniqueNestedInput[]
    | FieldUpsertWithWhereUniqueNestedInput;
  delete?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
  connect?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
  set?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
  disconnect?: FieldWhereUniqueInput[] | FieldWhereUniqueInput;
  deleteMany?: FieldScalarWhereInput[] | FieldScalarWhereInput;
  updateMany?:
    | FieldUpdateManyWithWhereNestedInput[]
    | FieldUpdateManyWithWhereNestedInput;
}

export interface FieldUpdateWithWhereUniqueNestedInput {
  where: FieldWhereUniqueInput;
  data: FieldUpdateDataInput;
}

export interface FieldUpsertWithWhereUniqueNestedInput {
  where: FieldWhereUniqueInput;
  update: FieldUpdateDataInput;
  create: FieldCreateInput;
}

export interface FieldScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: FieldType;
  type_not?: FieldType;
  type_in?: FieldType[] | FieldType;
  type_not_in?: FieldType[] | FieldType;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: FieldScalarWhereInput[] | FieldScalarWhereInput;
  OR?: FieldScalarWhereInput[] | FieldScalarWhereInput;
  NOT?: FieldScalarWhereInput[] | FieldScalarWhereInput;
}

export interface FieldUpdateManyWithWhereNestedInput {
  where: FieldScalarWhereInput;
  data: FieldUpdateManyDataInput;
}

export interface FieldUpdateManyDataInput {
  type?: FieldType;
  label?: String;
  description?: String;
}

export interface WorkflowUpsertWithWhereUniqueNestedInput {
  where: WorkflowWhereUniqueInput;
  update: WorkflowUpdateDataInput;
  create: WorkflowCreateInput;
}

export interface WorkflowScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: WorkflowScalarWhereInput[] | WorkflowScalarWhereInput;
  OR?: WorkflowScalarWhereInput[] | WorkflowScalarWhereInput;
  NOT?: WorkflowScalarWhereInput[] | WorkflowScalarWhereInput;
}

export interface WorkflowUpdateManyWithWhereNestedInput {
  where: WorkflowScalarWhereInput;
  data: WorkflowUpdateManyDataInput;
}

export interface WorkflowUpdateManyDataInput {
  name?: String;
  description?: String;
}

export interface InviteUpdateManyInput {
  create?: InviteCreateInput[] | InviteCreateInput;
  update?:
    | InviteUpdateWithWhereUniqueNestedInput[]
    | InviteUpdateWithWhereUniqueNestedInput;
  upsert?:
    | InviteUpsertWithWhereUniqueNestedInput[]
    | InviteUpsertWithWhereUniqueNestedInput;
  delete?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  connect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  set?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  disconnect?: InviteWhereUniqueInput[] | InviteWhereUniqueInput;
  deleteMany?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  updateMany?:
    | InviteUpdateManyWithWhereNestedInput[]
    | InviteUpdateManyWithWhereNestedInput;
}

export interface InviteUpdateWithWhereUniqueNestedInput {
  where: InviteWhereUniqueInput;
  data: InviteUpdateDataInput;
}

export interface InviteUpdateDataInput {
  email?: String;
  expireAt?: DateTimeInput;
  invitedBy?: UserUpdateOneRequiredInput;
}

export interface InviteUpsertWithWhereUniqueNestedInput {
  where: InviteWhereUniqueInput;
  update: InviteUpdateDataInput;
  create: InviteCreateInput;
}

export interface InviteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  expireAt?: DateTimeInput;
  expireAt_not?: DateTimeInput;
  expireAt_in?: DateTimeInput[] | DateTimeInput;
  expireAt_not_in?: DateTimeInput[] | DateTimeInput;
  expireAt_lt?: DateTimeInput;
  expireAt_lte?: DateTimeInput;
  expireAt_gt?: DateTimeInput;
  expireAt_gte?: DateTimeInput;
  AND?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  OR?: InviteScalarWhereInput[] | InviteScalarWhereInput;
  NOT?: InviteScalarWhereInput[] | InviteScalarWhereInput;
}

export interface InviteUpdateManyWithWhereNestedInput {
  where: InviteScalarWhereInput;
  data: InviteUpdateManyDataInput;
}

export interface InviteUpdateManyDataInput {
  email?: String;
  expireAt?: DateTimeInput;
}

export interface WorkspaceUpsertWithoutJobsInput {
  update: WorkspaceUpdateWithoutJobsDataInput;
  create: WorkspaceCreateWithoutJobsInput;
}

export interface WorkflowUpdateOneRequiredInput {
  create?: WorkflowCreateInput;
  update?: WorkflowUpdateDataInput;
  upsert?: WorkflowUpsertNestedInput;
  connect?: WorkflowWhereUniqueInput;
}

export interface WorkflowUpsertNestedInput {
  update: WorkflowUpdateDataInput;
  create: WorkflowCreateInput;
}

export interface LocationUpdateManyInput {
  create?: LocationCreateInput[] | LocationCreateInput;
  update?:
    | LocationUpdateWithWhereUniqueNestedInput[]
    | LocationUpdateWithWhereUniqueNestedInput;
  upsert?:
    | LocationUpsertWithWhereUniqueNestedInput[]
    | LocationUpsertWithWhereUniqueNestedInput;
  delete?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  connect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  set?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  disconnect?: LocationWhereUniqueInput[] | LocationWhereUniqueInput;
  deleteMany?: LocationScalarWhereInput[] | LocationScalarWhereInput;
  updateMany?:
    | LocationUpdateManyWithWhereNestedInput[]
    | LocationUpdateManyWithWhereNestedInput;
}

export interface LocationUpdateWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput;
  data: LocationUpdateDataInput;
}

export interface LocationUpdateDataInput {
  country?: String;
  region?: String;
  city?: String;
  zip?: String;
}

export interface LocationUpsertWithWhereUniqueNestedInput {
  where: LocationWhereUniqueInput;
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface LocationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  region?: String;
  region_not?: String;
  region_in?: String[] | String;
  region_not_in?: String[] | String;
  region_lt?: String;
  region_lte?: String;
  region_gt?: String;
  region_gte?: String;
  region_contains?: String;
  region_not_contains?: String;
  region_starts_with?: String;
  region_not_starts_with?: String;
  region_ends_with?: String;
  region_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  zip?: String;
  zip_not?: String;
  zip_in?: String[] | String;
  zip_not_in?: String[] | String;
  zip_lt?: String;
  zip_lte?: String;
  zip_gt?: String;
  zip_gte?: String;
  zip_contains?: String;
  zip_not_contains?: String;
  zip_starts_with?: String;
  zip_not_starts_with?: String;
  zip_ends_with?: String;
  zip_not_ends_with?: String;
  AND?: LocationScalarWhereInput[] | LocationScalarWhereInput;
  OR?: LocationScalarWhereInput[] | LocationScalarWhereInput;
  NOT?: LocationScalarWhereInput[] | LocationScalarWhereInput;
}

export interface LocationUpdateManyWithWhereNestedInput {
  where: LocationScalarWhereInput;
  data: LocationUpdateManyDataInput;
}

export interface LocationUpdateManyDataInput {
  country?: String;
  region?: String;
  city?: String;
  zip?: String;
}

export interface JobUpsertWithoutApplicationsInput {
  update: JobUpdateWithoutApplicationsDataInput;
  create: JobCreateWithoutApplicationsInput;
}

export interface ApplicationUpsertWithWhereUniqueWithoutCandidateInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutCandidateDataInput;
  create: ApplicationCreateWithoutCandidateInput;
}

export interface ApplicationScalarWhereInput {
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: ApplicationType;
  type_not?: ApplicationType;
  type_in?: ApplicationType[] | ApplicationType;
  type_not_in?: ApplicationType[] | ApplicationType;
  AND?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
  OR?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
  NOT?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
}

export interface ApplicationUpdateManyWithWhereNestedInput {
  where: ApplicationScalarWhereInput;
  data: ApplicationUpdateManyDataInput;
}

export interface ApplicationUpdateManyDataInput {
  type?: ApplicationType;
}

export interface CandidateUpsertWithoutTasksInput {
  update: CandidateUpdateWithoutTasksDataInput;
  create: CandidateCreateWithoutTasksInput;
}

export interface TaskUpsertWithWhereUniqueWithoutOwnersInput {
  where: TaskWhereUniqueInput;
  update: TaskUpdateWithoutOwnersDataInput;
  create: TaskCreateWithoutOwnersInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface DisqualificationInstanceUpsertNestedInput {
  update: DisqualificationInstanceUpdateDataInput;
  create: DisqualificationInstanceCreateInput;
}

export interface CandidateUpdateOneRequiredWithoutApplicationsInput {
  create?: CandidateCreateWithoutApplicationsInput;
  update?: CandidateUpdateWithoutApplicationsDataInput;
  upsert?: CandidateUpsertWithoutApplicationsInput;
  connect?: CandidateWhereUniqueInput;
}

export interface CandidateUpdateWithoutApplicationsDataInput {
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  sources?: SourceUpdateManyInput;
  fields?: FieldInstanceUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface CandidateUpsertWithoutApplicationsInput {
  update: CandidateUpdateWithoutApplicationsDataInput;
  create: CandidateCreateWithoutApplicationsInput;
}

export interface ApplicationUpdateManyMutationInput {
  type?: ApplicationType;
}

export interface CandidateUpdateInput {
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  avatar?: FileUpdateOneInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  resumesFile?: FileUpdateManyInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
  coverLettersFile?: FileUpdateManyInput;
  tags?: TagUpdateManyInput;
  sources?: SourceUpdateManyInput;
  fields?: FieldInstanceUpdateManyInput;
  tasks?: TaskUpdateManyWithoutCandidateInput;
  applications?: ApplicationUpdateManyWithoutCandidateInput;
  comments?: CommentUpdateManyInput;
}

export interface CandidateUpdateManyMutationInput {
  firstName?: String;
  lastName?: String;
  emails?: CandidateUpdateemailsInput;
  phones?: CandidateUpdatephonesInput;
  links?: CandidateUpdatelinksInput;
  company?: String;
  headline?: String;
  position?: String;
  resumesString?: CandidateUpdateresumesStringInput;
  coverLettersString?: CandidateUpdatecoverLettersStringInput;
}

export interface CommentUpdateInput {
  createdBy?: UserUpdateOneRequiredInput;
  parent?: CommentUpdateOneInput;
  content?: String;
}

export interface CommentUpdateManyMutationInput {
  content?: String;
}

export interface DisqualificationUpdateInput {
  name?: String;
  description?: String;
}

export interface DisqualificationUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface DisqualificationInstanceUpdateInput {
  disqualification?: DisqualificationUpdateOneRequiredInput;
  createdBy?: UserUpdateOneRequiredInput;
  content?: String;
}

export interface DisqualificationInstanceUpdateManyMutationInput {
  content?: String;
}

export interface FieldUpdateInput {
  type?: FieldType;
  label?: String;
  description?: String;
}

export interface FieldUpdateManyMutationInput {
  type?: FieldType;
  label?: String;
  description?: String;
}

export interface FieldInstanceUpdateInput {
  field?: FieldUpdateOneRequiredInput;
  value?: String;
}

export interface FieldInstanceUpdateManyMutationInput {
  value?: String;
}

export interface FileUpdateInput {
  size?: Int;
  type?: String;
  name?: String;
  url?: String;
}

export interface FileUpdateManyMutationInput {
  size?: Int;
  type?: String;
  name?: String;
  url?: String;
}

export interface InviteUpdateInput {
  email?: String;
  expireAt?: DateTimeInput;
  invitedBy?: UserUpdateOneRequiredInput;
}

export interface InviteUpdateManyMutationInput {
  email?: String;
  expireAt?: DateTimeInput;
}

export interface JobCreateInput {
  workspace: WorkspaceCreateOneWithoutJobsInput;
  applications?: ApplicationCreateManyWithoutJobInput;
  workflow: WorkflowCreateOneInput;
  comments?: CommentCreateManyInput;
  type: JobType;
  department?: String;
  locations?: LocationCreateManyInput;
  name: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface ApplicationCreateManyWithoutJobInput {
  create?:
    | ApplicationCreateWithoutJobInput[]
    | ApplicationCreateWithoutJobInput;
  connect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
}

export interface ApplicationCreateWithoutJobInput {
  type: ApplicationType;
  disqualification?: DisqualificationInstanceCreateOneInput;
  stage: StageCreateOneInput;
  candidate: CandidateCreateOneWithoutApplicationsInput;
}

export interface JobUpdateInput {
  workspace?: WorkspaceUpdateOneRequiredWithoutJobsInput;
  applications?: ApplicationUpdateManyWithoutJobInput;
  workflow?: WorkflowUpdateOneRequiredInput;
  comments?: CommentUpdateManyInput;
  type?: JobType;
  department?: String;
  locations?: LocationUpdateManyInput;
  name?: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface ApplicationUpdateManyWithoutJobInput {
  create?:
    | ApplicationCreateWithoutJobInput[]
    | ApplicationCreateWithoutJobInput;
  delete?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  connect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  set?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  disconnect?: ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput;
  update?:
    | ApplicationUpdateWithWhereUniqueWithoutJobInput[]
    | ApplicationUpdateWithWhereUniqueWithoutJobInput;
  upsert?:
    | ApplicationUpsertWithWhereUniqueWithoutJobInput[]
    | ApplicationUpsertWithWhereUniqueWithoutJobInput;
  deleteMany?: ApplicationScalarWhereInput[] | ApplicationScalarWhereInput;
  updateMany?:
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput;
}

export interface ApplicationUpdateWithWhereUniqueWithoutJobInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutJobDataInput;
}

export interface ApplicationUpdateWithoutJobDataInput {
  type?: ApplicationType;
  disqualification?: DisqualificationInstanceUpdateOneInput;
  stage?: StageUpdateOneRequiredInput;
  candidate?: CandidateUpdateOneRequiredWithoutApplicationsInput;
}

export interface ApplicationUpsertWithWhereUniqueWithoutJobInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutJobDataInput;
  create: ApplicationCreateWithoutJobInput;
}

export interface JobUpdateManyMutationInput {
  type?: JobType;
  department?: String;
  name?: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface LocationUpdateInput {
  country?: String;
  region?: String;
  city?: String;
  zip?: String;
}

export interface LocationUpdateManyMutationInput {
  country?: String;
  region?: String;
  city?: String;
  zip?: String;
}

export interface SourceUpdateInput {
  label?: String;
  description?: String;
}

export interface SourceUpdateManyMutationInput {
  label?: String;
  description?: String;
}

export interface StageUpdateInput {
  name?: String;
  description?: String;
  type?: StageType;
}

export interface StageUpdateManyMutationInput {
  name?: String;
  description?: String;
  type?: StageType;
}

export interface TagUpdateInput {
  label?: String;
  description?: String;
}

export interface TagUpdateManyMutationInput {
  label?: String;
  description?: String;
}

export interface TaskCreateInput {
  owners?: UserCreateManyWithoutTasksInput;
  candidate?: CandidateCreateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface TaskUpdateInput {
  owners?: UserUpdateManyWithoutTasksInput;
  candidate?: CandidateUpdateOneWithoutTasksInput;
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface TaskUpdateManyMutationInput {
  title?: String;
  description?: String;
  dueAt?: DateTimeInput;
}

export interface UserUpdateInput {
  settings?: Json;
  tasks?: TaskUpdateManyWithoutOwnersInput;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
  avatar?: FileUpdateOneInput;
}

export interface UserUpdateManyMutationInput {
  settings?: Json;
  firstName?: String;
  lastName?: String;
  email?: String;
  username?: String;
  lastLogin?: DateTimeInput;
  deletedAt?: DateTimeInput;
  position?: String;
}

export interface WorkflowUpdateInput {
  name?: String;
  description?: String;
  stages?: StageUpdateManyInput;
  disqualifications?: DisqualificationUpdateManyInput;
  fields?: FieldUpdateManyInput;
}

export interface WorkflowUpdateManyMutationInput {
  name?: String;
  description?: String;
}

export interface WorkspaceCreateInput {
  users?: UserCreateManyInput;
  jobs?: JobCreateManyWithoutWorkspaceInput;
  candidates?: CandidateCreateManyInput;
  settings?: Json;
  workflows?: WorkflowCreateManyInput;
  invites?: InviteCreateManyInput;
  name: String;
}

export interface JobCreateManyWithoutWorkspaceInput {
  create?: JobCreateWithoutWorkspaceInput[] | JobCreateWithoutWorkspaceInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
}

export interface JobCreateWithoutWorkspaceInput {
  applications?: ApplicationCreateManyWithoutJobInput;
  workflow: WorkflowCreateOneInput;
  comments?: CommentCreateManyInput;
  type: JobType;
  department?: String;
  locations?: LocationCreateManyInput;
  name: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface WorkspaceUpdateInput {
  users?: UserUpdateManyInput;
  jobs?: JobUpdateManyWithoutWorkspaceInput;
  candidates?: CandidateUpdateManyInput;
  settings?: Json;
  workflows?: WorkflowUpdateManyInput;
  invites?: InviteUpdateManyInput;
  name?: String;
}

export interface JobUpdateManyWithoutWorkspaceInput {
  create?: JobCreateWithoutWorkspaceInput[] | JobCreateWithoutWorkspaceInput;
  delete?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  connect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  set?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  disconnect?: JobWhereUniqueInput[] | JobWhereUniqueInput;
  update?:
    | JobUpdateWithWhereUniqueWithoutWorkspaceInput[]
    | JobUpdateWithWhereUniqueWithoutWorkspaceInput;
  upsert?:
    | JobUpsertWithWhereUniqueWithoutWorkspaceInput[]
    | JobUpsertWithWhereUniqueWithoutWorkspaceInput;
  deleteMany?: JobScalarWhereInput[] | JobScalarWhereInput;
  updateMany?:
    | JobUpdateManyWithWhereNestedInput[]
    | JobUpdateManyWithWhereNestedInput;
}

export interface JobUpdateWithWhereUniqueWithoutWorkspaceInput {
  where: JobWhereUniqueInput;
  data: JobUpdateWithoutWorkspaceDataInput;
}

export interface JobUpdateWithoutWorkspaceDataInput {
  applications?: ApplicationUpdateManyWithoutJobInput;
  workflow?: WorkflowUpdateOneRequiredInput;
  comments?: CommentUpdateManyInput;
  type?: JobType;
  department?: String;
  locations?: LocationUpdateManyInput;
  name?: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface JobUpsertWithWhereUniqueWithoutWorkspaceInput {
  where: JobWhereUniqueInput;
  update: JobUpdateWithoutWorkspaceDataInput;
  create: JobCreateWithoutWorkspaceInput;
}

export interface JobScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  type?: JobType;
  type_not?: JobType;
  type_in?: JobType[] | JobType;
  type_not_in?: JobType[] | JobType;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  excerpt?: String;
  excerpt_not?: String;
  excerpt_in?: String[] | String;
  excerpt_not_in?: String[] | String;
  excerpt_lt?: String;
  excerpt_lte?: String;
  excerpt_gt?: String;
  excerpt_gte?: String;
  excerpt_contains?: String;
  excerpt_not_contains?: String;
  excerpt_starts_with?: String;
  excerpt_not_starts_with?: String;
  excerpt_ends_with?: String;
  excerpt_not_ends_with?: String;
  companyDescription?: String;
  companyDescription_not?: String;
  companyDescription_in?: String[] | String;
  companyDescription_not_in?: String[] | String;
  companyDescription_lt?: String;
  companyDescription_lte?: String;
  companyDescription_gt?: String;
  companyDescription_gte?: String;
  companyDescription_contains?: String;
  companyDescription_not_contains?: String;
  companyDescription_starts_with?: String;
  companyDescription_not_starts_with?: String;
  companyDescription_ends_with?: String;
  companyDescription_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  requirements?: String;
  requirements_not?: String;
  requirements_in?: String[] | String;
  requirements_not_in?: String[] | String;
  requirements_lt?: String;
  requirements_lte?: String;
  requirements_gt?: String;
  requirements_gte?: String;
  requirements_contains?: String;
  requirements_not_contains?: String;
  requirements_starts_with?: String;
  requirements_not_starts_with?: String;
  requirements_ends_with?: String;
  requirements_not_ends_with?: String;
  AND?: JobScalarWhereInput[] | JobScalarWhereInput;
  OR?: JobScalarWhereInput[] | JobScalarWhereInput;
  NOT?: JobScalarWhereInput[] | JobScalarWhereInput;
}

export interface JobUpdateManyWithWhereNestedInput {
  where: JobScalarWhereInput;
  data: JobUpdateManyDataInput;
}

export interface JobUpdateManyDataInput {
  type?: JobType;
  department?: String;
  name?: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface WorkspaceUpdateManyMutationInput {
  settings?: Json;
  name?: String;
}

export interface ApplicationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ApplicationWhereInput;
  AND?: ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput;
  OR?: ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput;
  NOT?: ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput;
}

export interface CandidateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CandidateWhereInput;
  AND?: CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput;
  OR?: CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput;
  NOT?: CandidateSubscriptionWhereInput[] | CandidateSubscriptionWhereInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface DisqualificationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DisqualificationWhereInput;
  AND?:
    | DisqualificationSubscriptionWhereInput[]
    | DisqualificationSubscriptionWhereInput;
  OR?:
    | DisqualificationSubscriptionWhereInput[]
    | DisqualificationSubscriptionWhereInput;
  NOT?:
    | DisqualificationSubscriptionWhereInput[]
    | DisqualificationSubscriptionWhereInput;
}

export interface DisqualificationInstanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DisqualificationInstanceWhereInput;
  AND?:
    | DisqualificationInstanceSubscriptionWhereInput[]
    | DisqualificationInstanceSubscriptionWhereInput;
  OR?:
    | DisqualificationInstanceSubscriptionWhereInput[]
    | DisqualificationInstanceSubscriptionWhereInput;
  NOT?:
    | DisqualificationInstanceSubscriptionWhereInput[]
    | DisqualificationInstanceSubscriptionWhereInput;
}

export interface FieldSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FieldWhereInput;
  AND?: FieldSubscriptionWhereInput[] | FieldSubscriptionWhereInput;
  OR?: FieldSubscriptionWhereInput[] | FieldSubscriptionWhereInput;
  NOT?: FieldSubscriptionWhereInput[] | FieldSubscriptionWhereInput;
}

export interface FieldInstanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FieldInstanceWhereInput;
  AND?:
    | FieldInstanceSubscriptionWhereInput[]
    | FieldInstanceSubscriptionWhereInput;
  OR?:
    | FieldInstanceSubscriptionWhereInput[]
    | FieldInstanceSubscriptionWhereInput;
  NOT?:
    | FieldInstanceSubscriptionWhereInput[]
    | FieldInstanceSubscriptionWhereInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface InviteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InviteWhereInput;
  AND?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
  OR?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
  NOT?: InviteSubscriptionWhereInput[] | InviteSubscriptionWhereInput;
}

export interface JobSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: JobWhereInput;
  AND?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
  OR?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
  NOT?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface SourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SourceWhereInput;
  AND?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
  OR?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
  NOT?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
}

export interface StageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StageWhereInput;
  AND?: StageSubscriptionWhereInput[] | StageSubscriptionWhereInput;
  OR?: StageSubscriptionWhereInput[] | StageSubscriptionWhereInput;
  NOT?: StageSubscriptionWhereInput[] | StageSubscriptionWhereInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface TaskSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TaskWhereInput;
  AND?: TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput;
  OR?: TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput;
  NOT?: TaskSubscriptionWhereInput[] | TaskSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface WorkflowSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WorkflowWhereInput;
  AND?: WorkflowSubscriptionWhereInput[] | WorkflowSubscriptionWhereInput;
  OR?: WorkflowSubscriptionWhereInput[] | WorkflowSubscriptionWhereInput;
  NOT?: WorkflowSubscriptionWhereInput[] | WorkflowSubscriptionWhereInput;
}

export interface WorkspaceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WorkspaceWhereInput;
  AND?: WorkspaceSubscriptionWhereInput[] | WorkspaceSubscriptionWhereInput;
  OR?: WorkspaceSubscriptionWhereInput[] | WorkspaceSubscriptionWhereInput;
  NOT?: WorkspaceSubscriptionWhereInput[] | WorkspaceSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Application {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type: ApplicationType;
}

export interface ApplicationPromise extends Promise<Application>, Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ApplicationType>;
  disqualification: <T = DisqualificationInstancePromise>() => T;
  stage: <T = StagePromise>() => T;
  job: <T = JobPromise>() => T;
  candidate: <T = CandidatePromise>() => T;
}

export interface ApplicationSubscription
  extends Promise<AsyncIterator<Application>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<ApplicationType>>;
  disqualification: <T = DisqualificationInstanceSubscription>() => T;
  stage: <T = StageSubscription>() => T;
  job: <T = JobSubscription>() => T;
  candidate: <T = CandidateSubscription>() => T;
}

export interface DisqualificationInstance {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  content?: String;
}

export interface DisqualificationInstancePromise
  extends Promise<DisqualificationInstance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  disqualification: <T = DisqualificationPromise>() => T;
  createdBy: <T = UserPromise>() => T;
  content: () => Promise<String>;
}

export interface DisqualificationInstanceSubscription
  extends Promise<AsyncIterator<DisqualificationInstance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  disqualification: <T = DisqualificationSubscription>() => T;
  createdBy: <T = UserSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
}

export interface Disqualification {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
}

export interface DisqualificationPromise
  extends Promise<Disqualification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface DisqualificationSubscription
  extends Promise<AsyncIterator<Disqualification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  settings?: Json;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  position?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  settings: () => Promise<Json>;
  tasks: <T = FragmentableArray<Task>>(
    args?: {
      where?: TaskWhereInput;
      orderBy?: TaskOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  lastLogin: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  position: () => Promise<String>;
  avatar: <T = FilePromise>() => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  settings: () => Promise<AsyncIterator<Json>>;
  tasks: <T = Promise<AsyncIterator<TaskSubscription>>>(
    args?: {
      where?: TaskWhereInput;
      orderBy?: TaskOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  lastLogin: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  position: () => Promise<AsyncIterator<String>>;
  avatar: <T = FileSubscription>() => T;
}

export interface Task {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  dueAt?: DateTimeOutput;
}

export interface TaskPromise extends Promise<Task>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  owners: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  candidate: <T = CandidatePromise>() => T;
  title: () => Promise<String>;
  description: () => Promise<String>;
  dueAt: () => Promise<DateTimeOutput>;
}

export interface TaskSubscription
  extends Promise<AsyncIterator<Task>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  owners: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  candidate: <T = CandidateSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  dueAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Candidate {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  emails: String[];
  phones: String[];
  links: String[];
  company?: String;
  headline?: String;
  position?: String;
  resumesString: String[];
  coverLettersString: String[];
}

export interface CandidatePromise extends Promise<Candidate>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  emails: () => Promise<String[]>;
  phones: () => Promise<String[]>;
  links: () => Promise<String[]>;
  avatar: <T = FilePromise>() => T;
  company: () => Promise<String>;
  headline: () => Promise<String>;
  position: () => Promise<String>;
  resumesString: () => Promise<String[]>;
  resumesFile: <T = FragmentableArray<File>>(
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  coverLettersString: () => Promise<String[]>;
  coverLettersFile: <T = FragmentableArray<File>>(
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sources: <T = FragmentableArray<Source>>(
    args?: {
      where?: SourceWhereInput;
      orderBy?: SourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fields: <T = FragmentableArray<FieldInstance>>(
    args?: {
      where?: FieldInstanceWhereInput;
      orderBy?: FieldInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tasks: <T = FragmentableArray<Task>>(
    args?: {
      where?: TaskWhereInput;
      orderBy?: TaskOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  applications: <T = FragmentableArray<Application>>(
    args?: {
      where?: ApplicationWhereInput;
      orderBy?: ApplicationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CandidateSubscription
  extends Promise<AsyncIterator<Candidate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  emails: () => Promise<AsyncIterator<String[]>>;
  phones: () => Promise<AsyncIterator<String[]>>;
  links: () => Promise<AsyncIterator<String[]>>;
  avatar: <T = FileSubscription>() => T;
  company: () => Promise<AsyncIterator<String>>;
  headline: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  resumesString: () => Promise<AsyncIterator<String[]>>;
  resumesFile: <T = Promise<AsyncIterator<FileSubscription>>>(
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  coverLettersString: () => Promise<AsyncIterator<String[]>>;
  coverLettersFile: <T = Promise<AsyncIterator<FileSubscription>>>(
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sources: <T = Promise<AsyncIterator<SourceSubscription>>>(
    args?: {
      where?: SourceWhereInput;
      orderBy?: SourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fields: <T = Promise<AsyncIterator<FieldInstanceSubscription>>>(
    args?: {
      where?: FieldInstanceWhereInput;
      orderBy?: FieldInstanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tasks: <T = Promise<AsyncIterator<TaskSubscription>>>(
    args?: {
      where?: TaskWhereInput;
      orderBy?: TaskOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(
    args?: {
      where?: ApplicationWhereInput;
      orderBy?: ApplicationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface File {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  size: Int;
  type: String;
  name: String;
  url: String;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  size: () => Promise<Int>;
  type: () => Promise<String>;
  name: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  size: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface Tag {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  label: String;
  description?: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  label: () => Promise<String>;
  description: () => Promise<String>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  label: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface Source {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  label: String;
  description?: String;
}

export interface SourcePromise extends Promise<Source>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  label: () => Promise<String>;
  description: () => Promise<String>;
}

export interface SourceSubscription
  extends Promise<AsyncIterator<Source>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  label: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface FieldInstance {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  value?: String;
}

export interface FieldInstancePromise
  extends Promise<FieldInstance>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  field: <T = FieldPromise>() => T;
  value: () => Promise<String>;
}

export interface FieldInstanceSubscription
  extends Promise<AsyncIterator<FieldInstance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  field: <T = FieldSubscription>() => T;
  value: () => Promise<AsyncIterator<String>>;
}

export interface Field {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: FieldType;
  label: String;
  description?: String;
}

export interface FieldPromise extends Promise<Field>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<FieldType>;
  label: () => Promise<String>;
  description: () => Promise<String>;
}

export interface FieldSubscription
  extends Promise<AsyncIterator<Field>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<FieldType>>;
  label: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface Comment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  content: String;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  parent: <T = CommentPromise>() => T;
  content: () => Promise<String>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
  parent: <T = CommentSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
}

export interface Stage {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
  type: StageType;
}

export interface StagePromise extends Promise<Stage>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<StageType>;
}

export interface StageSubscription
  extends Promise<AsyncIterator<Stage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<StageType>>;
}

export interface Job {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: JobType;
  department?: String;
  name: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface JobPromise extends Promise<Job>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  workspace: <T = WorkspacePromise>() => T;
  applications: <T = FragmentableArray<Application>>(
    args?: {
      where?: ApplicationWhereInput;
      orderBy?: ApplicationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  workflow: <T = WorkflowPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  type: () => Promise<JobType>;
  department: () => Promise<String>;
  locations: <T = FragmentableArray<Location>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  name: () => Promise<String>;
  excerpt: () => Promise<String>;
  companyDescription: () => Promise<String>;
  description: () => Promise<String>;
  requirements: () => Promise<String>;
}

export interface JobSubscription
  extends Promise<AsyncIterator<Job>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  workspace: <T = WorkspaceSubscription>() => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(
    args?: {
      where?: ApplicationWhereInput;
      orderBy?: ApplicationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  workflow: <T = WorkflowSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  type: () => Promise<AsyncIterator<JobType>>;
  department: () => Promise<AsyncIterator<String>>;
  locations: <T = Promise<AsyncIterator<LocationSubscription>>>(
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  name: () => Promise<AsyncIterator<String>>;
  excerpt: () => Promise<AsyncIterator<String>>;
  companyDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  requirements: () => Promise<AsyncIterator<String>>;
}

export interface Workspace {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  settings?: Json;
  name: String;
}

export interface WorkspacePromise extends Promise<Workspace>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  jobs: <T = FragmentableArray<Job>>(
    args?: {
      where?: JobWhereInput;
      orderBy?: JobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  candidates: <T = FragmentableArray<Candidate>>(
    args?: {
      where?: CandidateWhereInput;
      orderBy?: CandidateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  settings: () => Promise<Json>;
  workflows: <T = FragmentableArray<Workflow>>(
    args?: {
      where?: WorkflowWhereInput;
      orderBy?: WorkflowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invites: <T = FragmentableArray<Invite>>(
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  name: () => Promise<String>;
}

export interface WorkspaceSubscription
  extends Promise<AsyncIterator<Workspace>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  jobs: <T = Promise<AsyncIterator<JobSubscription>>>(
    args?: {
      where?: JobWhereInput;
      orderBy?: JobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  candidates: <T = Promise<AsyncIterator<CandidateSubscription>>>(
    args?: {
      where?: CandidateWhereInput;
      orderBy?: CandidateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  settings: () => Promise<AsyncIterator<Json>>;
  workflows: <T = Promise<AsyncIterator<WorkflowSubscription>>>(
    args?: {
      where?: WorkflowWhereInput;
      orderBy?: WorkflowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invites: <T = Promise<AsyncIterator<InviteSubscription>>>(
    args?: {
      where?: InviteWhereInput;
      orderBy?: InviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Workflow {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
}

export interface WorkflowPromise extends Promise<Workflow>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  stages: <T = FragmentableArray<Stage>>(
    args?: {
      where?: StageWhereInput;
      orderBy?: StageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  disqualifications: <T = FragmentableArray<Disqualification>>(
    args?: {
      where?: DisqualificationWhereInput;
      orderBy?: DisqualificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fields: <T = FragmentableArray<Field>>(
    args?: {
      where?: FieldWhereInput;
      orderBy?: FieldOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WorkflowSubscription
  extends Promise<AsyncIterator<Workflow>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  stages: <T = Promise<AsyncIterator<StageSubscription>>>(
    args?: {
      where?: StageWhereInput;
      orderBy?: StageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  disqualifications: <T = Promise<AsyncIterator<DisqualificationSubscription>>>(
    args?: {
      where?: DisqualificationWhereInput;
      orderBy?: DisqualificationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fields: <T = Promise<AsyncIterator<FieldSubscription>>>(
    args?: {
      where?: FieldWhereInput;
      orderBy?: FieldOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Invite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  expireAt: DateTimeOutput;
}

export interface InvitePromise extends Promise<Invite>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  expireAt: () => Promise<DateTimeOutput>;
  invitedBy: <T = UserPromise>() => T;
}

export interface InviteSubscription
  extends Promise<AsyncIterator<Invite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  expireAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  invitedBy: <T = UserSubscription>() => T;
}

export interface Location {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  country: String;
  region?: String;
  city: String;
  zip?: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  country: () => Promise<String>;
  region: () => Promise<String>;
  city: () => Promise<String>;
  zip: () => Promise<String>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  country: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationConnection {
  pageInfo: PageInfo;
  edges: ApplicationEdge[];
}

export interface ApplicationConnectionPromise
  extends Promise<ApplicationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationEdge>>() => T;
  aggregate: <T = AggregateApplicationPromise>() => T;
}

export interface ApplicationConnectionSubscription
  extends Promise<AsyncIterator<ApplicationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicationSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationEdge {
  node: Application;
  cursor: String;
}

export interface ApplicationEdgePromise
  extends Promise<ApplicationEdge>,
    Fragmentable {
  node: <T = ApplicationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationEdgeSubscription
  extends Promise<AsyncIterator<ApplicationEdge>>,
    Fragmentable {
  node: <T = ApplicationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApplication {
  count: Int;
}

export interface AggregateApplicationPromise
  extends Promise<AggregateApplication>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationSubscription
  extends Promise<AsyncIterator<AggregateApplication>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CandidateConnection {
  pageInfo: PageInfo;
  edges: CandidateEdge[];
}

export interface CandidateConnectionPromise
  extends Promise<CandidateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CandidateEdge>>() => T;
  aggregate: <T = AggregateCandidatePromise>() => T;
}

export interface CandidateConnectionSubscription
  extends Promise<AsyncIterator<CandidateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CandidateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCandidateSubscription>() => T;
}

export interface CandidateEdge {
  node: Candidate;
  cursor: String;
}

export interface CandidateEdgePromise
  extends Promise<CandidateEdge>,
    Fragmentable {
  node: <T = CandidatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CandidateEdgeSubscription
  extends Promise<AsyncIterator<CandidateEdge>>,
    Fragmentable {
  node: <T = CandidateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCandidate {
  count: Int;
}

export interface AggregateCandidatePromise
  extends Promise<AggregateCandidate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCandidateSubscription
  extends Promise<AsyncIterator<AggregateCandidate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DisqualificationConnection {
  pageInfo: PageInfo;
  edges: DisqualificationEdge[];
}

export interface DisqualificationConnectionPromise
  extends Promise<DisqualificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DisqualificationEdge>>() => T;
  aggregate: <T = AggregateDisqualificationPromise>() => T;
}

export interface DisqualificationConnectionSubscription
  extends Promise<AsyncIterator<DisqualificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DisqualificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDisqualificationSubscription>() => T;
}

export interface DisqualificationEdge {
  node: Disqualification;
  cursor: String;
}

export interface DisqualificationEdgePromise
  extends Promise<DisqualificationEdge>,
    Fragmentable {
  node: <T = DisqualificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DisqualificationEdgeSubscription
  extends Promise<AsyncIterator<DisqualificationEdge>>,
    Fragmentable {
  node: <T = DisqualificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDisqualification {
  count: Int;
}

export interface AggregateDisqualificationPromise
  extends Promise<AggregateDisqualification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDisqualificationSubscription
  extends Promise<AsyncIterator<AggregateDisqualification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DisqualificationInstanceConnection {
  pageInfo: PageInfo;
  edges: DisqualificationInstanceEdge[];
}

export interface DisqualificationInstanceConnectionPromise
  extends Promise<DisqualificationInstanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DisqualificationInstanceEdge>>() => T;
  aggregate: <T = AggregateDisqualificationInstancePromise>() => T;
}

export interface DisqualificationInstanceConnectionSubscription
  extends Promise<AsyncIterator<DisqualificationInstanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<DisqualificationInstanceEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateDisqualificationInstanceSubscription>() => T;
}

export interface DisqualificationInstanceEdge {
  node: DisqualificationInstance;
  cursor: String;
}

export interface DisqualificationInstanceEdgePromise
  extends Promise<DisqualificationInstanceEdge>,
    Fragmentable {
  node: <T = DisqualificationInstancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DisqualificationInstanceEdgeSubscription
  extends Promise<AsyncIterator<DisqualificationInstanceEdge>>,
    Fragmentable {
  node: <T = DisqualificationInstanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDisqualificationInstance {
  count: Int;
}

export interface AggregateDisqualificationInstancePromise
  extends Promise<AggregateDisqualificationInstance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDisqualificationInstanceSubscription
  extends Promise<AsyncIterator<AggregateDisqualificationInstance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldConnection {
  pageInfo: PageInfo;
  edges: FieldEdge[];
}

export interface FieldConnectionPromise
  extends Promise<FieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FieldEdge>>() => T;
  aggregate: <T = AggregateFieldPromise>() => T;
}

export interface FieldConnectionSubscription
  extends Promise<AsyncIterator<FieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldSubscription>() => T;
}

export interface FieldEdge {
  node: Field;
  cursor: String;
}

export interface FieldEdgePromise extends Promise<FieldEdge>, Fragmentable {
  node: <T = FieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FieldEdgeSubscription
  extends Promise<AsyncIterator<FieldEdge>>,
    Fragmentable {
  node: <T = FieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateField {
  count: Int;
}

export interface AggregateFieldPromise
  extends Promise<AggregateField>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldSubscription
  extends Promise<AsyncIterator<AggregateField>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldInstanceConnection {
  pageInfo: PageInfo;
  edges: FieldInstanceEdge[];
}

export interface FieldInstanceConnectionPromise
  extends Promise<FieldInstanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FieldInstanceEdge>>() => T;
  aggregate: <T = AggregateFieldInstancePromise>() => T;
}

export interface FieldInstanceConnectionSubscription
  extends Promise<AsyncIterator<FieldInstanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldInstanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldInstanceSubscription>() => T;
}

export interface FieldInstanceEdge {
  node: FieldInstance;
  cursor: String;
}

export interface FieldInstanceEdgePromise
  extends Promise<FieldInstanceEdge>,
    Fragmentable {
  node: <T = FieldInstancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FieldInstanceEdgeSubscription
  extends Promise<AsyncIterator<FieldInstanceEdge>>,
    Fragmentable {
  node: <T = FieldInstanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFieldInstance {
  count: Int;
}

export interface AggregateFieldInstancePromise
  extends Promise<AggregateFieldInstance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldInstanceSubscription
  extends Promise<AsyncIterator<AggregateFieldInstance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InviteConnection {
  pageInfo: PageInfo;
  edges: InviteEdge[];
}

export interface InviteConnectionPromise
  extends Promise<InviteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InviteEdge>>() => T;
  aggregate: <T = AggregateInvitePromise>() => T;
}

export interface InviteConnectionSubscription
  extends Promise<AsyncIterator<InviteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InviteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInviteSubscription>() => T;
}

export interface InviteEdge {
  node: Invite;
  cursor: String;
}

export interface InviteEdgePromise extends Promise<InviteEdge>, Fragmentable {
  node: <T = InvitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface InviteEdgeSubscription
  extends Promise<AsyncIterator<InviteEdge>>,
    Fragmentable {
  node: <T = InviteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvite {
  count: Int;
}

export interface AggregateInvitePromise
  extends Promise<AggregateInvite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInviteSubscription
  extends Promise<AsyncIterator<AggregateInvite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface JobConnection {
  pageInfo: PageInfo;
  edges: JobEdge[];
}

export interface JobConnectionPromise
  extends Promise<JobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobEdge>>() => T;
  aggregate: <T = AggregateJobPromise>() => T;
}

export interface JobConnectionSubscription
  extends Promise<AsyncIterator<JobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobSubscription>() => T;
}

export interface JobEdge {
  node: Job;
  cursor: String;
}

export interface JobEdgePromise extends Promise<JobEdge>, Fragmentable {
  node: <T = JobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobEdgeSubscription
  extends Promise<AsyncIterator<JobEdge>>,
    Fragmentable {
  node: <T = JobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJob {
  count: Int;
}

export interface AggregateJobPromise
  extends Promise<AggregateJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobSubscription
  extends Promise<AsyncIterator<AggregateJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SourceConnection {
  pageInfo: PageInfo;
  edges: SourceEdge[];
}

export interface SourceConnectionPromise
  extends Promise<SourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SourceEdge>>() => T;
  aggregate: <T = AggregateSourcePromise>() => T;
}

export interface SourceConnectionSubscription
  extends Promise<AsyncIterator<SourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSourceSubscription>() => T;
}

export interface SourceEdge {
  node: Source;
  cursor: String;
}

export interface SourceEdgePromise extends Promise<SourceEdge>, Fragmentable {
  node: <T = SourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SourceEdgeSubscription
  extends Promise<AsyncIterator<SourceEdge>>,
    Fragmentable {
  node: <T = SourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSource {
  count: Int;
}

export interface AggregateSourcePromise
  extends Promise<AggregateSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSourceSubscription
  extends Promise<AsyncIterator<AggregateSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StageConnection {
  pageInfo: PageInfo;
  edges: StageEdge[];
}

export interface StageConnectionPromise
  extends Promise<StageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StageEdge>>() => T;
  aggregate: <T = AggregateStagePromise>() => T;
}

export interface StageConnectionSubscription
  extends Promise<AsyncIterator<StageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStageSubscription>() => T;
}

export interface StageEdge {
  node: Stage;
  cursor: String;
}

export interface StageEdgePromise extends Promise<StageEdge>, Fragmentable {
  node: <T = StagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface StageEdgeSubscription
  extends Promise<AsyncIterator<StageEdge>>,
    Fragmentable {
  node: <T = StageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStage {
  count: Int;
}

export interface AggregateStagePromise
  extends Promise<AggregateStage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStageSubscription
  extends Promise<AsyncIterator<AggregateStage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TaskConnection {
  pageInfo: PageInfo;
  edges: TaskEdge[];
}

export interface TaskConnectionPromise
  extends Promise<TaskConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TaskEdge>>() => T;
  aggregate: <T = AggregateTaskPromise>() => T;
}

export interface TaskConnectionSubscription
  extends Promise<AsyncIterator<TaskConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TaskEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTaskSubscription>() => T;
}

export interface TaskEdge {
  node: Task;
  cursor: String;
}

export interface TaskEdgePromise extends Promise<TaskEdge>, Fragmentable {
  node: <T = TaskPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TaskEdgeSubscription
  extends Promise<AsyncIterator<TaskEdge>>,
    Fragmentable {
  node: <T = TaskSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTask {
  count: Int;
}

export interface AggregateTaskPromise
  extends Promise<AggregateTask>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTaskSubscription
  extends Promise<AsyncIterator<AggregateTask>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkflowConnection {
  pageInfo: PageInfo;
  edges: WorkflowEdge[];
}

export interface WorkflowConnectionPromise
  extends Promise<WorkflowConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkflowEdge>>() => T;
  aggregate: <T = AggregateWorkflowPromise>() => T;
}

export interface WorkflowConnectionSubscription
  extends Promise<AsyncIterator<WorkflowConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkflowEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkflowSubscription>() => T;
}

export interface WorkflowEdge {
  node: Workflow;
  cursor: String;
}

export interface WorkflowEdgePromise
  extends Promise<WorkflowEdge>,
    Fragmentable {
  node: <T = WorkflowPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkflowEdgeSubscription
  extends Promise<AsyncIterator<WorkflowEdge>>,
    Fragmentable {
  node: <T = WorkflowSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkflow {
  count: Int;
}

export interface AggregateWorkflowPromise
  extends Promise<AggregateWorkflow>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkflowSubscription
  extends Promise<AsyncIterator<AggregateWorkflow>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkspaceConnection {
  pageInfo: PageInfo;
  edges: WorkspaceEdge[];
}

export interface WorkspaceConnectionPromise
  extends Promise<WorkspaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkspaceEdge>>() => T;
  aggregate: <T = AggregateWorkspacePromise>() => T;
}

export interface WorkspaceConnectionSubscription
  extends Promise<AsyncIterator<WorkspaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkspaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkspaceSubscription>() => T;
}

export interface WorkspaceEdge {
  node: Workspace;
  cursor: String;
}

export interface WorkspaceEdgePromise
  extends Promise<WorkspaceEdge>,
    Fragmentable {
  node: <T = WorkspacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkspaceEdgeSubscription
  extends Promise<AsyncIterator<WorkspaceEdge>>,
    Fragmentable {
  node: <T = WorkspaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkspace {
  count: Int;
}

export interface AggregateWorkspacePromise
  extends Promise<AggregateWorkspace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkspaceSubscription
  extends Promise<AsyncIterator<AggregateWorkspace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ApplicationSubscriptionPayload {
  mutation: MutationType;
  node: Application;
  updatedFields: String[];
  previousValues: ApplicationPreviousValues;
}

export interface ApplicationSubscriptionPayloadPromise
  extends Promise<ApplicationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationPreviousValuesPromise>() => T;
}

export interface ApplicationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicationPreviousValuesSubscription>() => T;
}

export interface ApplicationPreviousValues {
  createdAt: DateTimeOutput;
  id: ID_Output;
  updatedAt: DateTimeOutput;
  type: ApplicationType;
}

export interface ApplicationPreviousValuesPromise
  extends Promise<ApplicationPreviousValues>,
    Fragmentable {
  createdAt: () => Promise<DateTimeOutput>;
  id: () => Promise<ID_Output>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<ApplicationType>;
}

export interface ApplicationPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationPreviousValues>>,
    Fragmentable {
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  id: () => Promise<AsyncIterator<ID_Output>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<ApplicationType>>;
}

export interface CandidateSubscriptionPayload {
  mutation: MutationType;
  node: Candidate;
  updatedFields: String[];
  previousValues: CandidatePreviousValues;
}

export interface CandidateSubscriptionPayloadPromise
  extends Promise<CandidateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CandidatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CandidatePreviousValuesPromise>() => T;
}

export interface CandidateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CandidateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CandidateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CandidatePreviousValuesSubscription>() => T;
}

export interface CandidatePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  emails: String[];
  phones: String[];
  links: String[];
  company?: String;
  headline?: String;
  position?: String;
  resumesString: String[];
  coverLettersString: String[];
}

export interface CandidatePreviousValuesPromise
  extends Promise<CandidatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  emails: () => Promise<String[]>;
  phones: () => Promise<String[]>;
  links: () => Promise<String[]>;
  company: () => Promise<String>;
  headline: () => Promise<String>;
  position: () => Promise<String>;
  resumesString: () => Promise<String[]>;
  coverLettersString: () => Promise<String[]>;
}

export interface CandidatePreviousValuesSubscription
  extends Promise<AsyncIterator<CandidatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  emails: () => Promise<AsyncIterator<String[]>>;
  phones: () => Promise<AsyncIterator<String[]>>;
  links: () => Promise<AsyncIterator<String[]>>;
  company: () => Promise<AsyncIterator<String>>;
  headline: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  resumesString: () => Promise<AsyncIterator<String[]>>;
  coverLettersString: () => Promise<AsyncIterator<String[]>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  content: String;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface DisqualificationSubscriptionPayload {
  mutation: MutationType;
  node: Disqualification;
  updatedFields: String[];
  previousValues: DisqualificationPreviousValues;
}

export interface DisqualificationSubscriptionPayloadPromise
  extends Promise<DisqualificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DisqualificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DisqualificationPreviousValuesPromise>() => T;
}

export interface DisqualificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DisqualificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DisqualificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DisqualificationPreviousValuesSubscription>() => T;
}

export interface DisqualificationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
}

export interface DisqualificationPreviousValuesPromise
  extends Promise<DisqualificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface DisqualificationPreviousValuesSubscription
  extends Promise<AsyncIterator<DisqualificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface DisqualificationInstanceSubscriptionPayload {
  mutation: MutationType;
  node: DisqualificationInstance;
  updatedFields: String[];
  previousValues: DisqualificationInstancePreviousValues;
}

export interface DisqualificationInstanceSubscriptionPayloadPromise
  extends Promise<DisqualificationInstanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DisqualificationInstancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DisqualificationInstancePreviousValuesPromise>() => T;
}

export interface DisqualificationInstanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DisqualificationInstanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DisqualificationInstanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = DisqualificationInstancePreviousValuesSubscription
  >() => T;
}

export interface DisqualificationInstancePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  content?: String;
}

export interface DisqualificationInstancePreviousValuesPromise
  extends Promise<DisqualificationInstancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface DisqualificationInstancePreviousValuesSubscription
  extends Promise<AsyncIterator<DisqualificationInstancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface FieldSubscriptionPayload {
  mutation: MutationType;
  node: Field;
  updatedFields: String[];
  previousValues: FieldPreviousValues;
}

export interface FieldSubscriptionPayloadPromise
  extends Promise<FieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldPreviousValuesPromise>() => T;
}

export interface FieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldPreviousValuesSubscription>() => T;
}

export interface FieldPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: FieldType;
  label: String;
  description?: String;
}

export interface FieldPreviousValuesPromise
  extends Promise<FieldPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<FieldType>;
  label: () => Promise<String>;
  description: () => Promise<String>;
}

export interface FieldPreviousValuesSubscription
  extends Promise<AsyncIterator<FieldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<FieldType>>;
  label: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface FieldInstanceSubscriptionPayload {
  mutation: MutationType;
  node: FieldInstance;
  updatedFields: String[];
  previousValues: FieldInstancePreviousValues;
}

export interface FieldInstanceSubscriptionPayloadPromise
  extends Promise<FieldInstanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldInstancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldInstancePreviousValuesPromise>() => T;
}

export interface FieldInstanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldInstanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldInstanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldInstancePreviousValuesSubscription>() => T;
}

export interface FieldInstancePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  value?: String;
}

export interface FieldInstancePreviousValuesPromise
  extends Promise<FieldInstancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface FieldInstancePreviousValuesSubscription
  extends Promise<AsyncIterator<FieldInstancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  size: Int;
  type: String;
  name: String;
  url: String;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  size: () => Promise<Int>;
  type: () => Promise<String>;
  name: () => Promise<String>;
  url: () => Promise<String>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  size: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface InviteSubscriptionPayload {
  mutation: MutationType;
  node: Invite;
  updatedFields: String[];
  previousValues: InvitePreviousValues;
}

export interface InviteSubscriptionPayloadPromise
  extends Promise<InviteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvitePreviousValuesPromise>() => T;
}

export interface InviteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InviteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InviteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvitePreviousValuesSubscription>() => T;
}

export interface InvitePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  expireAt: DateTimeOutput;
}

export interface InvitePreviousValuesPromise
  extends Promise<InvitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  expireAt: () => Promise<DateTimeOutput>;
}

export interface InvitePreviousValuesSubscription
  extends Promise<AsyncIterator<InvitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  expireAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface JobSubscriptionPayload {
  mutation: MutationType;
  node: Job;
  updatedFields: String[];
  previousValues: JobPreviousValues;
}

export interface JobSubscriptionPayloadPromise
  extends Promise<JobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPreviousValuesPromise>() => T;
}

export interface JobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPreviousValuesSubscription>() => T;
}

export interface JobPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  type: JobType;
  department?: String;
  name: String;
  excerpt?: String;
  companyDescription?: String;
  description?: String;
  requirements?: String;
}

export interface JobPreviousValuesPromise
  extends Promise<JobPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  type: () => Promise<JobType>;
  department: () => Promise<String>;
  name: () => Promise<String>;
  excerpt: () => Promise<String>;
  companyDescription: () => Promise<String>;
  description: () => Promise<String>;
  requirements: () => Promise<String>;
}

export interface JobPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<JobType>>;
  department: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  excerpt: () => Promise<AsyncIterator<String>>;
  companyDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  requirements: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  country: String;
  region?: String;
  city: String;
  zip?: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  country: () => Promise<String>;
  region: () => Promise<String>;
  city: () => Promise<String>;
  zip: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  country: () => Promise<AsyncIterator<String>>;
  region: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
}

export interface SourceSubscriptionPayload {
  mutation: MutationType;
  node: Source;
  updatedFields: String[];
  previousValues: SourcePreviousValues;
}

export interface SourceSubscriptionPayloadPromise
  extends Promise<SourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SourcePreviousValuesPromise>() => T;
}

export interface SourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SourcePreviousValuesSubscription>() => T;
}

export interface SourcePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  label: String;
  description?: String;
}

export interface SourcePreviousValuesPromise
  extends Promise<SourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  label: () => Promise<String>;
  description: () => Promise<String>;
}

export interface SourcePreviousValuesSubscription
  extends Promise<AsyncIterator<SourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  label: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface StageSubscriptionPayload {
  mutation: MutationType;
  node: Stage;
  updatedFields: String[];
  previousValues: StagePreviousValues;
}

export interface StageSubscriptionPayloadPromise
  extends Promise<StageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StagePreviousValuesPromise>() => T;
}

export interface StageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StagePreviousValuesSubscription>() => T;
}

export interface StagePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
  type: StageType;
}

export interface StagePreviousValuesPromise
  extends Promise<StagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<StageType>;
}

export interface StagePreviousValuesSubscription
  extends Promise<AsyncIterator<StagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<StageType>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  label: String;
  description?: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  label: () => Promise<String>;
  description: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  label: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface TaskSubscriptionPayload {
  mutation: MutationType;
  node: Task;
  updatedFields: String[];
  previousValues: TaskPreviousValues;
}

export interface TaskSubscriptionPayloadPromise
  extends Promise<TaskSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TaskPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TaskPreviousValuesPromise>() => T;
}

export interface TaskSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TaskSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TaskSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TaskPreviousValuesSubscription>() => T;
}

export interface TaskPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title?: String;
  description?: String;
  dueAt?: DateTimeOutput;
}

export interface TaskPreviousValuesPromise
  extends Promise<TaskPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  dueAt: () => Promise<DateTimeOutput>;
}

export interface TaskPreviousValuesSubscription
  extends Promise<AsyncIterator<TaskPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  dueAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  settings?: Json;
  firstName: String;
  lastName: String;
  email: String;
  username: String;
  lastLogin?: DateTimeOutput;
  deletedAt?: DateTimeOutput;
  position?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  settings: () => Promise<Json>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  username: () => Promise<String>;
  lastLogin: () => Promise<DateTimeOutput>;
  deletedAt: () => Promise<DateTimeOutput>;
  position: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  settings: () => Promise<AsyncIterator<Json>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  lastLogin: () => Promise<AsyncIterator<DateTimeOutput>>;
  deletedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  position: () => Promise<AsyncIterator<String>>;
}

export interface WorkflowSubscriptionPayload {
  mutation: MutationType;
  node: Workflow;
  updatedFields: String[];
  previousValues: WorkflowPreviousValues;
}

export interface WorkflowSubscriptionPayloadPromise
  extends Promise<WorkflowSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkflowPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkflowPreviousValuesPromise>() => T;
}

export interface WorkflowSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkflowSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkflowSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkflowPreviousValuesSubscription>() => T;
}

export interface WorkflowPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  description?: String;
}

export interface WorkflowPreviousValuesPromise
  extends Promise<WorkflowPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface WorkflowPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkflowPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface WorkspaceSubscriptionPayload {
  mutation: MutationType;
  node: Workspace;
  updatedFields: String[];
  previousValues: WorkspacePreviousValues;
}

export interface WorkspaceSubscriptionPayloadPromise
  extends Promise<WorkspaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkspacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkspacePreviousValuesPromise>() => T;
}

export interface WorkspaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkspaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkspaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkspacePreviousValuesSubscription>() => T;
}

export interface WorkspacePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  settings?: Json;
  name: String;
}

export interface WorkspacePreviousValuesPromise
  extends Promise<WorkspacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  settings: () => Promise<Json>;
  name: () => Promise<String>;
}

export interface WorkspacePreviousValuesSubscription
  extends Promise<AsyncIterator<WorkspacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  settings: () => Promise<AsyncIterator<Json>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Json = any;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Workspace",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Job",
    embedded: false
  },
  {
    name: "Application",
    embedded: false
  },
  {
    name: "Candidate",
    embedded: false
  },
  {
    name: "Task",
    embedded: false
  },
  {
    name: "Invite",
    embedded: false
  },
  {
    name: "Workflow",
    embedded: false
  },
  {
    name: "Disqualification",
    embedded: false
  },
  {
    name: "DisqualificationInstance",
    embedded: false
  },
  {
    name: "Stage",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Field",
    embedded: false
  },
  {
    name: "FieldInstance",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Source",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "JobType",
    embedded: false
  },
  {
    name: "ApplicationType",
    embedded: false
  },
  {
    name: "StageType",
    embedded: false
  },
  {
    name: "FieldType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}/${
    process.env["PRISMA_SERVICE"]
  }/${process.env["PRISMA_STAGE"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
