# import * from "../../../node_modules/graphql-override/dist/directives.graphql"

# import Query.*, Mutation.*, * from "../../generated/prisma.graphql"
# import Query.*, Mutation.*, * from "../schema.graphql"

# import * from "connections.graphql"

# USER
type User {
  # system
  workspace: Workspace! @replace

  password: String @remove
}

input UserWhereInput @exclude {
  # system
  workspace: WorkspaceWhereInput

  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
}

input UserUpdateInput {
  password: String @remove
  workspace: WorkspaceUpdateOneWithoutUsersInput @remove

  # only notification update is status
  notifications: NotificationUpdateInput

  # only sensible action on subsciption from user update view is connect/disconnect
  subscriptionJobs: ConnectDisconnectMany @replace
  subscriptionCandidates: ConnectDisconnectMany @replace
  subscriptionTasks: ConnectDisconnectMany @replace
}

enum UserOrderByInput @exclude {
  password_ASC
  password_DESC
}

# NOTIFICATION
type Notification {
  # replacing where inputs
  user: User! @replace
  event: Event! @replace
}

input NotificationUpdateInput {
  # user & event are binded for whole lifecycle of notification
  user: UserUpdateOneWithoutNotificationsInput @remove
  event: EventUpdateOneInput @remove
}

# CANDIDATE
type Candidate {
  workspace: Workspace! @replace
}

input CandidateWhereInput @exclude {
  workspace: Workspace!
}

input CandidateUpdateInput {
  # system
  workspace: WorkspaceUpdateOneWithoutCandidatesInput @remove

  # too complex
  tasks: TaskUpdateManyWithoutCandidateInput @remove
  applications: ApplicationUpdateManyWithoutCandidateInput @remove
  comments: CommentUpdateManyInput @remove

  # connections
  subscribers: Connect @replace
}

# JOB
type Job {
  workspace: Workspace! @replace
}

input JobWhereInput @exclude {
  workspace: Workspace!
}

input JobCreateInput {
  # system
  workspace: WorkspaceCreateOneWithoutJobsInput! @remove
  events: EventCreateManyWithoutTargetJobInput @remove

  # doesn't make sense on job creation
  applications: ApplicationCreateManyWithoutJobInput @remove
  comments: CommentCreateManyInput @remove

  #connections
  subscribers: ConnectMany @replace
}

input JobUpdateInput {
  # system
  workspace: WorkspaceUpdateOneWithoutJobsInput @remove
  events: EventUpdateManyWithoutTargetJobInput @remove

  # connections
  subscribers: ConnectDisconnectMany @replace

  # Too complicated
  applications: ApplicationUpdateManyWithoutJobInput @remove
}

# APPLICATION
type Application {
  workspace: Workspace! @replace
}

input ApplicationWhereInput @exclude {
  workspace: Workspace!
}

input ApplicationCreateInput {
  workspace: WorkspaceCreateOneWithoutApplicationsInput! @remove

  # connections
  job: Connect! @replace
  candidate: Connect! @replace
  stage: Connect @replace
}

input ApplicationUpdateInput {
  workspace: WorkspaceUpdateOneWithoutApplicationsInput @remove

  # connections
  # job/candidate is fixed for application
  job: ConnectDisconnect @replace
  candidate: ConnectDisconnect @remove
  # Application must have a stage so only connect
  stage: Connect @replace
}

# TASK
type Task {
  workspace: Workspace! @replace
}

input TaskWhereInput @exclude {
  workspace: Workspace!
}

input TaskCreateInput {
  # system
  workspace: WorkspaceCreateOneInput! @remove

  # connections
  subscribers: ConnectMany @replace
  owners: ConnectMany @replace
  job: Connect @replace
  candidate: Connect @replace
}

input TaskUpdateInput {
  # system
  workspace: WorkspaceUpdateOneInput @remove

  # connections
  subscribers: ConnectDisconnectMany @replace
  owners: ConnectDisconnectMany @replace
  job: ConnectDisconnect @replace
  candidate: ConnectDisconnect @replace
}
